/// \file Signal.h
/*
*
* Signal.h header template automatically generated by a class generator
* Creation date : lun. janv. 23 2017
*
* This file is part of DQM4HEP libraries.
*
* DQM4HEP is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQM4HEP is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Remi Ete
* @copyright CNRS , IPNL
*/


#ifndef SIGNAL_H
#define SIGNAL_H

namespace dqm4hep {

  namespace core {

    /**
    *  @brief SignalBase class.
    *         Base class to store callback function
    */
    template <typename ...Args>
    class SignalBase
    {
    public:
      typedef std::vector<SignalBase<Args...> *>  Vector;

      /**
      *  @brief  Destructor
      */
      virtual ~SignalBase() {}

      /**
      *  @brief  Process the callback
      */
      virtual void process(Args ...args) = 0;
    };


    template <>
    class SignalBase<void>
    {
    public:
      typedef std::vector<SignalBase<void> *>  Vector;

      /**
      *  @brief  Destructor
      */
      virtual ~SignalBase() {}

      /**
      *  @brief  Process the callback
      */
      virtual void process() = 0;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    /**
    *  @brief  SignalT class.
    */
    template <typename T, typename ...Args>
    class SignalT : public SignalBase<Args ...>
    {
    public:
      typedef void (T::*Function)(Args...args);

      /**
      *  @brief  Constructor with
      */
      SignalT(T *pClass, Function function);

      /**
      *  @brief  Process the callback
      */
      void process(Args ...args);

      /**
       *
       */
      const T *getClass() const;

      /**
       *
       */
      const Function getFunction() const;

    private:
      T                 *m_pClass;
      Function           m_function;
    };

    template <typename T>
    class SignalT<T, void> : public SignalBase<void>
    {
    public:
      typedef void (T::*Function)();

      /**
      *  @brief  Constructor with
      */
      SignalT(T *pClass, Function function);

      /**
      *  @brief  Process the callback
      */
      void process();

      /**
       *
       */
      const T *getClass() const;

      /**
       *
       */
      const Function getFunction() const;

    private:
      T                 *m_pClass;
      Function           m_function;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename ...Args>
    class Signal
    {
    public:
      /**
      *
      */
      ~Signal();

      /**
      *
      */
      void process(Args ...args);

      /**
      *
      */
      template <typename T, typename S>
      bool connect(T *pClass, S function);

      /**
      *
      */
      template <typename T>
      bool disconnect(T *pClass);

      /**
      *
      */
      void disconnectAll();

      /**
      *
      */
      template <typename T>
      bool isConnected(T *pClass) const;

      /**
      *
      */
      bool hasConnection() const;

    private:
      typename SignalBase<Args...>::Vector           m_callbacks;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <>
    class Signal<void>
    {
    public:
      /**
      *
      */
      ~Signal();

      /**
      *
      */
      void process();

      /**
      *
      */
      template <typename T, typename S>
      bool connect(T *pClass, S function);

      /**
      *
      */
      template <typename T>
      bool disconnect(T *pClass);

      /**
      *
      */
      void disconnectAll();

      /**
      *
      */
      template <typename T>
      bool isConnected(T *pClass) const;

      /**
      *
      */
      bool hasConnection() const;

    private:
      typename SignalBase<void>::Vector           m_callbacks;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename ...Args>
    inline Signal<Args ...>::~Signal()
    {
      this->disconnectAll();
    }

    //----------------------------------------------------------------------------------

    template <typename ...Args>
    inline void Signal<Args ...>::process(Args ...args)
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
        (*iter)->process(args...);
    }

    //----------------------------------------------------------------------------------

    template <typename ...Args>
    template <typename T, typename S>
    inline bool Signal<Args ...>::connect(T *pClass, S function)
    {
      // check for existing connection
      if(this->isConnected(pClass))
        return false;

      // add the callback
      m_callbacks.push_back(new SignalT<T, Args...>(pClass, function));

      return true;
    }

    //----------------------------------------------------------------------------------

    template <typename ...Args>
    template <typename T>
    inline bool Signal<Args ...>::disconnect(T *pClass)
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
      {
        SignalT<T, Args...> *pCallBackT(dynamic_cast<SignalT<T, Args...> *>(*iter));

        if(!pCallBackT)
          continue;

        if(pCallBackT->getClass() == pClass)
        {
          delete pCallBackT;
          m_callbacks.erase(iter);
          return true;
        }
      }

      return false;
    }

    //----------------------------------------------------------------------------------

    template <typename ...Args>
    inline void Signal<Args ...>::disconnectAll()
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
        delete *iter;

      m_callbacks.clear();
    }

    //----------------------------------------------------------------------------------

    template <typename ...Args>
    template <typename T>
    inline bool Signal<Args ...>::isConnected(T *pClass) const
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
      {
        const SignalT<T, Args...> *pCallBackT(dynamic_cast<const SignalT<T, Args...> *>(*iter));

        if(!pCallBackT)
          continue;

        if(pCallBackT->getClass() == pClass)
          return true;
      }

      return false;
    }

    //----------------------------------------------------------------------------------

    template <typename ...Args>
    inline bool Signal<Args ...>::hasConnection() const
    {
      return (!m_callbacks.empty());
    }

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    inline Signal<void>::~Signal()
    {
      this->disconnectAll();
    }

    //----------------------------------------------------------------------------------

    inline void Signal<void>::process()
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
        (*iter)->process();
    }

    //----------------------------------------------------------------------------------

    template <typename T, typename S>
    inline bool Signal<void>::connect(T *pClass, S function)
    {
      // check for existing connection
      if(this->isConnected(pClass))
        return false;

      // add the callback
      m_callbacks.push_back(new SignalT<T, void>(pClass, function));

      return true;
    }

    //----------------------------------------------------------------------------------

    template <typename T>
    inline bool Signal<void>::disconnect(T *pClass)
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
      {
        SignalT<T, void> *pCallBackT(dynamic_cast<SignalT<T, void> *>(*iter));

        if(!pCallBackT)
          continue;

        if(pCallBackT->getClass() == pClass)
        {
          delete pCallBackT;
          m_callbacks.erase(iter);
          return true;
        }
      }

      return false;
    }

    //----------------------------------------------------------------------------------

    inline void Signal<void>::disconnectAll()
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
        delete *iter;

      m_callbacks.clear();
    }

    //----------------------------------------------------------------------------------

    template <typename T>
    inline bool Signal<void>::isConnected(T *pClass) const
    {
      for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
      {
        const SignalT<T, void> *pCallBackT(dynamic_cast<const SignalT<T, void> *>(*iter));

        if(!pCallBackT)
          continue;

        if(pCallBackT->getClass() == pClass)
          return true;
      }

      return false;
    }

    //----------------------------------------------------------------------------------

    inline bool Signal<void>::hasConnection() const
    {
      return (!m_callbacks.empty());
    }

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename T, typename ...Args>
    inline SignalT<T, Args...>::SignalT(T *pClass, Function function) :
      m_pClass(pClass),
      m_function(function)
    {
      /* nop */
    }

    //----------------------------------------------------------------------------------

    template <typename T, typename ...Args>
    inline void SignalT<T, Args...>::process(Args... args)
    {
      (m_pClass->*m_function)(args...);
    }

    //----------------------------------------------------------------------------------

    template <typename T, typename ...Args>
    inline const T *SignalT<T, Args...>::getClass() const
    {
      return m_pClass;
    }

    //----------------------------------------------------------------------------------

    template <typename T, typename ...Args>
    inline const typename SignalT<T, Args...>::Function SignalT<T, Args...>::getFunction() const
    {
      return m_function;
    }

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename T>
    inline SignalT<T, void>::SignalT(T *pClass, Function function) :
      m_pClass(pClass),
      m_function(function)
    {
      /* nop */
    }

    //----------------------------------------------------------------------------------

    template <typename T>
    inline void SignalT<T, void>::process()
    {
      (m_pClass->*m_function)();
    }

    //----------------------------------------------------------------------------------

    template <typename T>
    inline const T *SignalT<T, void>::getClass() const
    {
      return m_pClass;
    }

    //----------------------------------------------------------------------------------

    template <typename T>
    inline const typename SignalT<T, void>::Function SignalT<T, void>::getFunction() const
    {
      return m_function;
    }

  }

}

#endif  //  SIGNAL_H
