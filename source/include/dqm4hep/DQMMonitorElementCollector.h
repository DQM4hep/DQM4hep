/*
 *
 * DQMMonitorElementCollector.h header template automatically generated by a class generator
 * Creation date : ven. mai 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMMONITORELEMENTCOLLECTOR_H
#define DQMMONITORELEMENTCOLLECTOR_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMPath.h"
#include "dqm4hep/DQMStreamingHelper.h"

// -- dim headers
#include "dis.hxx"

namespace dqm4hep
{

class DQMMonitorElementCollector;
class DQMStorage;

/** ModuleMeInfo class
 */
class ModuleMeInfo
{
private:
	/** MeInfo struct
	 */
	struct MeInfo
	{
		std::set<int>         m_clientList;
		DQMMonitorElement    *m_pMonitorElement;
	};
	typedef std::map<std::string,  MeInfo *> MeInfoMap;

public:
	/** Constructor
	 */
	ModuleMeInfo();

	/** Destructor
	 */
	~ModuleMeInfo();

	/** Set the list of monitor element available on the module application
	 */
	void setAvailableMeList(const DQMMonitorElementInfoList &meNameList);

	/** Get the list of monitor element available on the module application
	 */
	const DQMMonitorElementInfoList &getAvailableMeList() const;

	/** Update the monitor element entry.
	 *  Return whether the monitor element was updated
	 */
	bool updateMonitorElement(DQMMonitorElement *pMonitorElement);

	/** Get a specific monitor element.
	 *  Return NULL is the entry doesn't exists
	 */
	DQMMonitorElement *getMonitorElement(const std::string &meName, bool partialCompare = false, bool lowerCaseCompare = false) const;

	/** Get the subscribed me name list. Simply iterate over stored monitor element
	 *  and add the element to list if a client has subscribed to it
	 */
	StringSet getSubscribedList() const;

	/** Get the subscribed me name list for a particular client
	 */
	StringSet getSubscribedList(int clientID) const;

	/** Get the subscribed me list for a particular client
	 */
	DQMMonitorElementList getSubscribedMeList(int clientID) const;

	/** Subscribe client to a monitor element.
	 *
	 *  Return a pair :
	 *    * first -> the new size of the subscriber clients
	 *    * second -> whether the client was inserted in the subscriber list
	 */
	std::pair<size_t, bool> subscribe(int clientID, const std::string &meName);

	/** Un-subscribe client from a monitor element.
	 *
	 *  Return a pair :
	 *    * first -> the new size of the subscriber clients
	 *    * second -> whether the client was erased from the subscriber list
	 */
	std::pair<size_t, bool> unsubscribe(int clientID, const std::string &meName);

	/** Unsubscribe all the elements for this client.
	 *  Return true if the client at least unsubscribe to one element
	 */
	bool unsubscribe(int clientID);

	/** Get the number of clients that have subscribe from a particular a monitor element
	 */
	size_t getNSubscribers(const std::string &meName) const;

	/** Get the number of clients that have subscribes to this module
	 */
	size_t getNSubscribers() const;

	/** Get the list of subscribers for a particular monitor element
	 */
	std::set<int> getSubscribers(const std::string &meName) const;

private:
	DQMMonitorElementInfoList                          m_availableMeList;
	StringSet                                          m_requestedMeList;
	MeInfoMap                                          m_meInfoMap;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** ClientInfo class
 */
class ClientInfo
{
public:
	/** Constructor for monitor element clients
	 */
	ClientInfo(int clientID);

	/** Constructor for module clients
	 */
	ClientInfo(int clientId, const std::string &moduleName);

	/** Get the module name.
	 *  Valid only if the client is a module.
	 */
	const std::string &getModuleName() const;

	/** Whether the client is a module.
	 *  Opposite is a monitor element client
	 */
	bool isModule() const;

	/** Get the client id
	 */
	int getClientID() const;

	/** Set update mode (default is false)
	 */
	void setUpdateMode(bool update);

	/** Whether the client works in update mode
	 */
	bool hasUpdateMode() const;

private:
	int                  m_clientID;
	bool                 m_updateMode;
	bool                 m_isModule;
	std::string          m_moduleName;
};

typedef std::map<int, ClientInfo>  ClientMap;

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

class DQMMonitorElementNameListRpc : public DimRpc
{
public:
	DQMMonitorElementNameListRpc(char *rpcName, DQMMonitorElementCollector *pCollector);
	void rpcHandler();

private:
	DQMMonitorElementCollector   *m_pCollector;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

class DQMMonitorElementCollectorInfoRpc : public DimRpc
{
public:
	DQMMonitorElementCollectorInfoRpc(char *rpcName, DQMMonitorElementCollector *pCollector);
	void rpcHandler();

private:
	DQMMonitorElementCollector   *m_pCollector;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMMonitorElementCollector class
 */ 
class DQMMonitorElementCollector : public DimServer
{
public:
	/** Constructor
	 */
	DQMMonitorElementCollector();

	/** Destructor
	 */
	~DQMMonitorElementCollector();

	/** Set the collector name. Can be set only if the collector is not running.
	 *  The collector name is used to build the service and command names over the network
	 */
	StatusCode setCollectorName(const std::string &collectorName);

	/** Get the collector name
	 */
	const std::string &getCollectorName() const;

	/** Start the collector. Allocate services and commands
	 */
	StatusCode start();

	/** Stop the collector. Destroy the commands and services
	 */
	StatusCode stop();

	/** Get the collector state. See DQMState enum (DQM4HEP.h)
	 */
	DQMState getState() const;

	/** Whether the collector is running
	 */
	bool isRunning() const;

public:
	typedef std::map<std::string, DQMMonitorElementList>   DQMMonitorElementListMap; ///< Module name to element list map
	typedef std::map<std::string, ModuleMeInfo *>          ModuleMeInfoMap;  ///< Module element storage
	typedef std::set<DQMMonitorElement *>                  DQMMonitorElementSet;
	typedef std::map<int, DQMMonitorElementSet>            ClientUpdateMap;  ///< Map of monitor element list to update

	static const std::string         m_emptyBufferStr;

private:
	/** Dim command handler
	 */
	void commandHandler();

	/** Dim client exit handler
	 */
	void clientExitHandler();


	/** Update client side with the monitor elements
	 */
	void updateClients(const ClientUpdateMap &clientUpdateMap, bool forceUpdate = false);

	/** Handle the monitor element packet reception from a module application
	 */
	void handleMeCollectUpdate(DimCommand *pCommand);

	/** Handle the available list of monitor element on module side
	 */
	void handleAvailableListUpdate(DimCommand *pCommand);

	/** Handle a client subscription
	 */
	void handleClientSubscription(int clientID, DimCommand *pCommand);

	/** Handle a client unsubscription
	 */
	void handleClientUnsubscription(int clientID, DimCommand *pCommand);

	/** Handle client automatic update mode
	 */
	void handleClientUpdateMode(int clientId, bool updateMode);

	/** Handle client me name request list update
	 */
	void handleClientRequestList(int clientId, DimCommand *pCommand);

	/** Handle the me query of target client id
	 */
	void handleMeQuery(int clientId, DimCommand *pCommand);


	/** Update the monitor element publication service for a specific client
	 */
	void sendMeUpdate(int clientID);

	/** Notify the module that users are watching a different set of
	 *  monitor elements provided by the module
	 */
	void notifyWatchedMe(const std::string &moduleName);


	/** Register a monitor element client
	 */
	bool registerClient(int clientId);

	/** Register a module client
	 */
	bool registerClient(int clientId, const std::string moduleName);

	/** De-register a client
	 */
	bool deregisterClient(int clientId);

	/** Get the module client ID.
	 *  Return 0 is not found (invalid for dim)
	 */
	int getModuleClientID(const std::string &moduleName) const;

	/**
	 */
	void configureInBuffer( char *pBuffer , uint32_t bufferSize );

private:
	// collector name
	std::string                        m_collectorName;

	// dim related
	DQMMonitorElementNameListRpc      *m_pMonitorElementNameListRpc;
	DQMMonitorElementCollectorInfoRpc *m_pMonitorElementCollectorInfoRpc;

	DimCommand                        *m_pCollectMeCommand;
	DimCommand                        *m_pAvailableMeListCommand;
	DimCommand                        *m_pMeQueryCommand;
	DimCommand                        *m_pSetUpdateModeCommand;
	DimCommand                        *m_pSubscribeCommand;
	DimCommand                        *m_pUnsubscribeCommand;
	DimCommand                        *m_pSetSubscriptionCommand;
	DimCommand                        *m_pQuerySubscribedCommand;

	DimService                        *m_pMeUpdateService;
	DimService                        *m_pNotifyWatchedMeService;
	DimService                        *m_pCollectorStateService;
	DQMStatisticsService              *m_pStatisticsService;

	// runtime
	int                                m_collectorState;
	xdrstream::BufferDevice           *m_pInBuffer;
	xdrstream::BufferDevice           *m_pOutBuffer;

	// clients and storage
	ModuleMeInfoMap                    m_moduleMeInfoMap;
	ClientMap                          m_clientMap;

	friend class DQMCollectorCommandHandler;
	friend class DQMMonitorElementNameListRpc;
	friend class DQMMonitorElementCollectorInfoRpc;
}; 

} 

#endif  //  DQMMONITORELEMENTCOLLECTOR_H
