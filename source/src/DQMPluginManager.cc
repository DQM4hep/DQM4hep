/*
 *
 * DQMPluginManager.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMLogging.h"

// -- std headers
#include <dlfcn.h>
#include <cstdlib>

namespace dqm4hep
{

DQMPluginManager::DQMPluginManager()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMPluginManager::~DQMPluginManager()
{
	for( DQMPluginMap::const_iterator iter = m_pluginMap.begin(), endIter = m_pluginMap.end() ;
			endIter != iter ; ++iter )
	{
		delete iter->second;
	}

	m_pluginMap.clear();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMPluginManager::loadLibraries()
{
	// get the environment plug-in dll variable
	char *pPluginDllEnv = getenv( "DQM4HEP_PLUGIN_DLL" );

	if( pPluginDllEnv == 0 )
	{
		LOG4CXX_WARN( dqmMainLogger , "Environment variable DQM4HEP_PLUGIN_DLL not found ! \n"
				"Set it before loading shared libraries. \n"
				"Example : export DQM4HEP_PLUGIN_DLL=libPlugin1.so:libPlugin2.so" );

		return STATUS_CODE_SUCCESS;
	}

	// split the string into a list
	std::string libraryConcatenateList( pPluginDllEnv );
	StringVector libraryList;

	DQM4HEP::tokenize( libraryConcatenateList, libraryList, ":" );

	// load the shared libraries
	return this->loadLibraries( libraryList );
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMPluginManager::loadLibraries( const StringVector &libraryNameList )
{
	for( StringVector::const_iterator iter = libraryNameList.begin(), endIter = libraryNameList.end() ;
			endIter != iter ; ++iter )
	{
		RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->loadLibrary( *iter ) );
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMPluginManager::loadLibrary( const std::string &libraryName )
{
	size_t idx = libraryName.find_last_of( "/" );

	// the library basename, i.e. /path/to/libBlah.so --> libBlah.so
	std::string libBaseName( libraryName.substr( idx + 1 ) );

	char *real_path = realpath( libraryName.c_str(), NULL );

	if( NULL != real_path )
	{
		LOG4CXX_INFO( dqmMainLogger , "<!-- Loading shared library : " << real_path << " ("<< libBaseName << ")-->" );

		// use real_path
		free( real_path );
	}
	else
	{
		LOG4CXX_INFO( dqmMainLogger , "<!-- Loading shared library : " << libraryName << " ("<< libBaseName << ")-->" );
	}

	void *pLibPointer = dlopen( libraryName.c_str(), RTLD_LAZY | RTLD_GLOBAL );

	if( pLibPointer == 0 )
	{
		LOG4CXX_ERROR( dqmMainLogger , "<!-- ERROR loading shared library : " << libraryName << "\n"
												<< "    ->    "   << dlerror() << " -->" );

		return STATUS_CODE_FAILURE;
	}
	else
		return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMPlugin *DQMPluginManager::getPlugin( const std::string &pluginName ) const
{
	if( ! isPluginRegistered( pluginName ) )
		return 0;

	return m_pluginMap.find( pluginName )->second;
}

//-------------------------------------------------------------------------------------------------

bool DQMPluginManager::isPluginRegistered( const std::string &pluginName ) const
{
	return ( m_pluginMap.find( pluginName ) != m_pluginMap.end() );
}

//-------------------------------------------------------------------------------------------------

StringVector DQMPluginManager::getPluginNameList() const
{
	StringVector pluginNameList;

	for( DQMPluginMap::const_iterator iter = m_pluginMap.begin(), endIter = m_pluginMap.end() ;
			endIter != iter ; ++iter )
	{
		pluginNameList.push_back( iter->first );
	}

	return pluginNameList;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMPluginManager::registerPlugin( DQMPlugin *pPlugin )
{
	// null ptr case
	if( NULL == pPlugin )
		return STATUS_CODE_INVALID_PTR;

	// check if the plug is already registered
	if( isPluginRegistered( pPlugin->getPluginName() ) )
	{
		delete pPlugin;
		pPlugin = NULL;
		return STATUS_CODE_ALREADY_PRESENT;
	}

	// try to register it
	if( ! m_pluginMap.insert( DQMPluginMap::value_type( pPlugin->getPluginName(), pPlugin ) ).second )
	{
		delete pPlugin;
		pPlugin = NULL;

		return STATUS_CODE_FAILURE;
	}

	return STATUS_CODE_SUCCESS;
}

} 

