  /// \file DQMQualityTest.cc
/*
 *
 * DQMQualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMQualityTest.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMDataStream.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMXmlHelper.h"

// -- root headers
#include "TMath.h"
#include "TH1.h"
#include "TF1.h"

namespace dqm4hep
{

DQMQualityTestResult::DQMQualityTestResult() :
		m_quality(NO_QUALITY),
		m_isSuccessful(true)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMQualityTestResult::DQMQualityTestResult(const DQMQualityTestResult &qualityTestResult)
{
	*this = qualityTestResult;
}

//-------------------------------------------------------------------------------------------------

DQMQualityTestResult &DQMQualityTestResult::operator=(const DQMQualityTestResult &qualityTestResult)
{
	m_qualityTestType = qualityTestResult.m_qualityTestType;
	m_qualityTestName = qualityTestResult.m_qualityTestName;
	m_message = qualityTestResult.m_message;
	m_quality = qualityTestResult.m_quality;
	m_isSuccessful = qualityTestResult.m_isSuccessful;

	return *this;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMQualityTestResult::serialize(DQMDataStream *const pDataStream) const
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(m_qualityTestType));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(m_qualityTestName));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(m_message));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(static_cast<dqm_int>(m_quality)));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->write(m_isSuccessful));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMQualityTestResult::deserialize(DQMDataStream *const pDataStream)
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(m_qualityTestType));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(m_qualityTestName));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(m_message));

	dqm_int quality = static_cast<dqm_int>(m_quality);
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(quality));
	m_quality = static_cast<DQMQuality>(quality);

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDataStream->read(m_isSuccessful));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMQualityTest::DQMQualityTest(const std::string &name) :
		m_name(name),
		m_quality(NO_QUALITY),
		m_isSuccessful(true)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMQualityTest::~DQMQualityTest() 
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMQualityTest::getType() const
{
	return m_type;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMQualityTest::getName() const
{
	return m_name;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMQualityTest::getMessage() const
{
	return m_message;
}

//-------------------------------------------------------------------------------------------------

bool DQMQualityTest::isSuccessful() const
{
	return m_isSuccessful;
}

//-------------------------------------------------------------------------------------------------

DQMQuality DQMQualityTest::getQuality() const
{
	return m_quality;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMQualityTest::run(DQMMonitorElement *pMonitorElement, DQMQualityTestResult &result)
{
	result.m_qualityTestType = this->getType();
	result.m_qualityTestName = this->getName();

	if(this->canRun(pMonitorElement))
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, run(pMonitorElement));

		result.m_message = getMessage();
		result.m_isSuccessful = isSuccessful();
		result.m_quality = getQuality();
	}
	else
	{
		result.m_message = "Couldn't run quality test";
		result.m_isSuccessful = false;
		result.m_quality = NO_QUALITY;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMeanWithinExpectedTest::DQMMeanWithinExpectedTest(const std::string &name) :
	DQMQualityTest(name),
	m_strategy(0),
	m_xMin(0.f),
	m_xMax(0.f),
	m_expectedMean(0.f),
	m_sigma(0.f)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMeanWithinExpectedTest::~DQMMeanWithinExpectedTest()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMeanWithinExpectedTest::readSettings(const TiXmlHandle xmlHandle)
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
			"Strategy", m_strategy));

	if(0 == m_strategy)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
				"XMin", m_xMin));

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
				"XMax", m_xMax));
	}
	else if(1 == m_strategy)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
				"ExpectedMean", m_expectedMean));

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
				"Sigma", m_sigma));
	}
	else if(2 == m_strategy)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
				"ExpectedMean", m_expectedMean));
	}
	else
		return STATUS_CODE_INVALID_PARAMETER;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMeanWithinExpectedTest::init()
{
	/* nop */
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMeanWithinExpectedTest::run(DQMMonitorElement *pMonitorElement)
{
	m_isSuccessful = false;
	m_quality = NO_QUALITY;
	m_message = "";

	TH1 *pHistogram = pMonitorElement->get<TH1>();

	if(0 == m_strategy)
	{
		float mean = pHistogram->GetMean();

		// test failed ?
		if(mean < m_xMin || mean > m_xMax)
		{
			m_quality = VERY_BAD_QUALITY;
			m_message = "Out of range !";
		}
		else
		{
			m_quality = VERY_GOOD_QUALITY;
			m_message = "";
		}

		m_isSuccessful = true;
	}
	else if(1 == m_strategy)
	{
		float chi = (pHistogram->GetMean() - m_expectedMean)/m_sigma;
		float probability = TMath::Prob(chi*chi, 1);

		m_quality = DQM4HEP::scaleToQuality(probability);
		m_isSuccessful = true;
	}
	else if(2 == m_strategy)
	{
		float chi = (pHistogram->GetMean() - m_expectedMean)/pHistogram->GetRMS();
		float probability = TMath::Prob(chi*chi, 1);

		m_quality = DQM4HEP::scaleToQuality(probability);
		m_isSuccessful = true;
	}
	else
	{
		m_isSuccessful = false;
		m_quality = NO_QUALITY;
		m_message = "Undefined strategy for this test";
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMMeanWithinExpectedTest::canRun(DQMMonitorElement *pMonitorElement) const
{
	if(NULL == pMonitorElement)
		return false;

	DQMMonitorElementType type = pMonitorElement->getType();
	TH1 *pHistogram = pMonitorElement->get<TH1>();

	// asking for a histo 1D
	if(type < INT_HISTOGRAM_1D_ELEMENT_TYPE || type > CHAR_HISTOGRAM_1D_ELEMENT_TYPE)
		return false;

	if(NULL == pHistogram)
		return false;

	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMChi2FitFunctionTest::DQMChi2FitFunctionTest(const std::string &name) :
	DQMQualityTest(name),
	m_functionXMin(0.f),
	m_functionXMax(1.f),
	m_functionNParameters(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMChi2FitFunctionTest::~DQMChi2FitFunctionTest()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMChi2FitFunctionTest::readSettings(const TiXmlHandle xmlHandle)
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
			"Formula", m_formula));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readVectorOfValues(xmlHandle,
			"InputParameterList", m_inputParameterList));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
			"FunctionNParameters", m_functionNParameters));

	if(!m_inputParameterList.empty() && m_inputParameterList.size() != m_functionNParameters)
		return STATUS_CODE_INVALID_PARAMETER;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
			"FunctionXMin", m_functionXMin));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::readValue(xmlHandle,
			"FunctionXMax", m_functionXMax));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMChi2FitFunctionTest::init()
{
	/* nop */
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMChi2FitFunctionTest::run(DQMMonitorElement *pMonitorElement)
{
	m_isSuccessful = false;
	m_quality = NO_QUALITY;
	m_message = "";

	TH1 *pHistogram = pMonitorElement->get<TH1>();

	std::string functionName = "DQMChi2FitFunctionTest_"+ getName() +"_fitFunction";

	// we need to remove the function from the TH1
	// since when TH1::Fit is called, the function
	// is stored in the TH1. The function is removed and deleted
	// since we don't know if the formula is the same as the user provides
	TF1 *pFitFunction = pHistogram->GetFunction(functionName.c_str());

	if(pFitFunction)
	{
		pHistogram->RecursiveRemove(pFitFunction);
		delete pFitFunction;
		pFitFunction = NULL;
	}

	// declare the fit function and fill the parameter list
	pFitFunction = new TF1(functionName.c_str(), m_formula.c_str(), m_functionXMin, m_functionXMax);//, m_functionNParameters);

	// set the parameters depending on if an
	// input has been provided or not by the user
	for(unsigned int p=0 ; p<m_functionNParameters ; p++)
		pFitFunction->SetParameter(p, m_inputParameterList.empty() ? 0 : m_inputParameterList.at(p));

	// Q for quiet
	// N for no draw
	int status = pHistogram->Fit(pFitFunction, "QN", "", m_functionXMin, m_functionXMax);

	if(status != 0)
	{
		m_message = "Try to fit function '"+ m_formula + "' with histogram '" + pMonitorElement->getName() + "'. " +
				"Fit failed and returned status " + DQM4HEP::typeToString(status);

		return STATUS_CODE_SUCCESS;
	}

	double chi2 = pFitFunction->GetChisquare();
	double proba = TMath::Prob(chi2, m_inputParameterList.size());

	m_isSuccessful = true;
	m_quality = DQM4HEP::scaleToQuality(proba);
	m_message = "Function '"+ m_formula +"' fitted on histogram '" + pMonitorElement->getName() + "' ends with the following output :\n" +
			"Chi2 = " + DQM4HEP::typeToString(chi2) + "\n" +
			"Excess probability = " + DQM4HEP::typeToString(proba) + "\n" +
			"Output parameters : \n";

	for(unsigned int p=0 ; p<m_functionNParameters ; p++)
		m_message += (" p" + DQM4HEP::typeToString(p) + " = " + DQM4HEP::typeToString(pFitFunction->GetParameter(p)) + "\n");

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMChi2FitFunctionTest::canRun(DQMMonitorElement *pMonitorElement) const
{
	if(NULL == pMonitorElement)
		return false;

	DQMMonitorElementType type = pMonitorElement->getType();
	TH1 *pHistogram = pMonitorElement->get<TH1>();

	// asking for a histo 1D
	if(type < INT_HISTOGRAM_1D_ELEMENT_TYPE || type > CHAR_HISTOGRAM_1D_ELEMENT_TYPE)
		return false;

	if(NULL == pHistogram)
		return false;

	return true;
}

} 

