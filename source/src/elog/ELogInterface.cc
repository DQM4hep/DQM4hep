  /// \file ELogInterface.cc
/*
 *
 * ELogInterface.cc source template automatically generated by a class generator
 * Creation date : mar. juin 2 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/elog/ELogInterface.h"
#include "DQMCoreConfig.h"

// -- std headers
#include <cstdlib>

namespace dqm4hep
{

ELog::ELog() :
		m_eLogCommand(DQM4HEP_ELOG_EXECUTABLE),
		m_host(""),
		m_port(80),
		m_userName(""),
		m_password(""),
		m_logbook(""),
		m_encoding(ELog::PLAIN),
		m_useSSL(false),
		m_suppresssEmailNotification(false)
{
#ifndef DQM4HEP_USE_ELOG
	throw StatusCodeException(STATUS_COE_FAILURE);
#endif
}

//-------------------------------------------------------------------------------------------------

ELog::ELog(const std::string &host, int port) :
		m_eLogCommand(DQM4HEP_ELOG_EXECUTABLE),
		m_host(host),
		m_port(port),
		m_userName(""),
		m_password(""),
		m_logbook(""),
		m_encoding(ELog::PLAIN),
		m_useSSL(false),
		m_suppresssEmailNotification(false)
{
#ifndef DQM4HEP_USE_ELOG
	throw StatusCodeException(STATUS_COE_FAILURE);
#endif
}

//-------------------------------------------------------------------------------------------------

ELog::ELog(const std::string &host, int port, const std::string &userName, const std::string &password) :
		m_eLogCommand(DQM4HEP_ELOG_EXECUTABLE),
		m_host(host),
		m_port(port),
		m_userName(userName),
		m_password(password),
		m_logbook(""),
		m_encoding(ELog::PLAIN),
		m_useSSL(false),
		m_suppresssEmailNotification(false)
{
#ifndef DQM4HEP_USE_ELOG
	throw StatusCodeException(STATUS_COE_FAILURE);
#endif
}

//-------------------------------------------------------------------------------------------------

void ELog::setHost(const std::string &host)
{
	m_host = host;
}

//-------------------------------------------------------------------------------------------------

void ELog::setPort(int port)
{
	m_port = port;
}

//-------------------------------------------------------------------------------------------------

void ELog::setUser(const std::string &user)
{
	m_userName = user;
}

//-------------------------------------------------------------------------------------------------

void ELog::setPassword(const std::string &password)
{
	m_password = password;
}

//-------------------------------------------------------------------------------------------------

void ELog::setLogbook(const std::string &logbook)
{
	m_logbook = logbook;
}

//-------------------------------------------------------------------------------------------------

void ELog::useSSL(bool useSSL)
{
	m_useSSL = useSSL;
}

//-------------------------------------------------------------------------------------------------

void ELog::setEncoding(Encoding encoding)
{
	m_encoding = encoding;
}

//-------------------------------------------------------------------------------------------------

void ELog::suppressEmailNotification(bool suppress)
{
	m_suppresssEmailNotification = suppress;
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::addEntry(const std::string &name, const std::string &value)
{
	if(name.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	m_logbookEntryMap[name] = value;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::addEntry(const LogbookEntry &entry)
{
	if(entry.first.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	m_logbookEntryMap[entry.first] = entry.second;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::addEntries(const LogbookEntryMap &entryMap)
{
	for(LogbookEntryMap::const_iterator iter = entryMap.begin(), endIter = entryMap.end() ;
			endIter != iter ; ++iter)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addEntry(iter->first, iter->second));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void ELog::setMessage(const std::string &message)
{
	m_message = message;
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::log()
{
	if(!checkConsistency())
		return STATUS_CODE_FAILURE;

	if(processELogCommand())
		return STATUS_CODE_FAILURE;

	clear();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::log(const LogbookEntryMap &entryMap, const std::string &message)
{
	clear();
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addEntries(entryMap));
	setMessage(message);
	return this->log();
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::log(const std::string &logbook)
{
	setLogbook(logbook);
	return this->log();
}

//-------------------------------------------------------------------------------------------------

StatusCode ELog::log(const std::string &logbook, const LogbookEntryMap &entryMap, const std::string &message)
{
	setLogbook(logbook);
	setMessage(message);
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addEntries(entryMap));
	return this->log();
}

//-------------------------------------------------------------------------------------------------

bool ELog::checkConsistency() const
{
	if(m_eLogCommand.empty()
	|| m_host.empty()
	|| m_userName.empty()
	|| m_password.empty()
	|| m_logbook.empty()
	|| m_logbookEntryMap.empty())
		return false;

	if(m_logbookEntryMap.size() > 50)
		return false;

	return true;
}

//-------------------------------------------------------------------------------------------------

int ELog::processELogCommand() const
{
	std::stringstream command;
	command << m_eLogCommand
			<< " -h \"" << m_host << "\""
			<< " -p " << m_port
			<< " -u \"" << m_userName << "\" \"" << m_password << "\""
			<< " -l \"" << m_logbook << "\"";

	for(LogbookEntryMap::const_iterator iter = m_logbookEntryMap.begin(), endIter = m_logbookEntryMap.end() ;
			endIter != iter ; ++iter)
	{
		command << " -a \"" << iter->first << "\"=\"" << iter->second << "\"";
	}

	command << " -n " << m_encoding;

	if(m_useSSL)
		command << " -s ";

	if(m_suppresssEmailNotification)
		command << " -x ";

	command << " \"" << m_message << "\"";

	streamlog_out(MESSAGE) << "Processing logbook command : '" << command.str() << "'" << std::endl;
	return system(command.str().c_str());
}

//-------------------------------------------------------------------------------------------------

void ELog::clear()
{
	m_logbookEntryMap.clear();
}

} 

