/*
 *
 * DQMMonitorElementCollector.cc source template automatically generated by a class generator
 * Creation date : ven. mai 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementCollector.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMStatisticsService.h"
#include "dqm4hep/DQMCoreTool.h"

/// -- std headers
#include <sys/utsname.h>
#include <unistd.h>
#include <algorithm>

namespace dqm4hep
{

static const char pMeCollectormptyBuffer [] = "EMPTY";

ModuleMeInfo::ModuleMeInfo()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

ModuleMeInfo::~ModuleMeInfo()
{
	for(MeInfoMap::iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;
}

//-------------------------------------------------------------------------------------------------

void ModuleMeInfo::setAvailableMeList(const DQMMonitorElementInfoList &meNameList)
{
	m_availableMeList = meNameList;
}

//-------------------------------------------------------------------------------------------------

const DQMMonitorElementInfoList &ModuleMeInfo::getAvailableMeList() const
{
	return m_availableMeList;
}

//-------------------------------------------------------------------------------------------------

bool ModuleMeInfo::updateMonitorElement(DQMMonitorElementPtr &monitorElement)
{
	if(NULL == monitorElement)
		return false;

	// full name = path + name
	std::string fullName = (monitorElement->getPath() + monitorElement->getName()).getPath();

	if(fullName.at(0) != '/')
		fullName = "/" + fullName;

	// look for an existing entry
	MeInfoMap::iterator findIter = m_meInfoMap.find(fullName);

	if(findIter == m_meInfoMap.end())
	{
		MeInfo *pMeInfo = new MeInfo();
		std::pair<MeInfoMap::iterator, bool> ret = m_meInfoMap.insert(MeInfoMap::value_type(fullName, pMeInfo));

		if(!ret.second)
		{
			delete pMeInfo;
			return false;
		}

		findIter = ret.first;
	}

	// replace it !
	findIter->second->m_monitorElement = monitorElement;

	return true;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementPtr ModuleMeInfo::getMonitorElement(const std::string &meName, bool partialCompare, bool lowerCaseCompare) const
{
	std::string elementNameToCompare = meName;

	if(lowerCaseCompare)
		std::transform(elementNameToCompare.begin(), elementNameToCompare.end(), elementNameToCompare.begin(), ::tolower);

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		std::string elementName = iter->first;

		if(lowerCaseCompare)
			std::transform(elementName.begin(), elementName.end(), elementName.begin(), ::tolower);

		if(partialCompare)
		{
			if(elementName.find(elementNameToCompare) == std::string::npos)
				continue;
		}
		else
		{
			if(elementName != elementNameToCompare)
				continue;
		}

		return iter->second->m_monitorElement;
	}

	return DQMMonitorElementPtr();
}

//-------------------------------------------------------------------------------------------------

StringSet ModuleMeInfo::getSubscribedList() const
{
	StringSet requestedMeList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if( ! iter->second->m_clientList.empty() )
			requestedMeList.insert( iter->first );
	}

	return requestedMeList;
}

//-------------------------------------------------------------------------------------------------

StringSet ModuleMeInfo::getSubscribedList(int clientID) const
{
	StringSet requestedMeList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if( iter->second->m_clientList.find(clientID) != iter->second->m_clientList.end() )
			requestedMeList.insert( iter->first );
	}

	return requestedMeList;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementPtrList ModuleMeInfo::getSubscribedMeList(int clientID) const
{
	DQMMonitorElementPtrList meList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		LOG4CXX_DEBUG( dqmMainLogger , "getSubscribedMeList(), me : " << iter->first );

		if( iter->second->m_clientList.find(clientID) != iter->second->m_clientList.end() )
		{
			LOG4CXX_DEBUG( dqmMainLogger , "Client " << clientID << " subscribed to it !" );

			if( NULL != iter->second->m_monitorElement )
			{
				LOG4CXX_DEBUG( dqmMainLogger , "Element is not null. Pushed back !" );
				meList.push_back( iter->second->m_monitorElement );
			}
		}
	}

	return meList;
}

//-------------------------------------------------------------------------------------------------

std::pair<size_t, bool> ModuleMeInfo::subscribe(int clientID, const std::string &meName)
{
	MeInfoMap::iterator findIter = m_meInfoMap.find(meName);

	// if not existing, look if available
	if(findIter == m_meInfoMap.end())
	{
		bool found = false;

		for(DQMMonitorElementInfoList::iterator iter = m_availableMeList.begin(), endIter = m_availableMeList.end() ;
				endIter != iter ; ++iter)
		{
			std::string fullName = (DQMPath( (*iter)[DQMKey::ME_PATH]) + (*iter)[DQMKey::ME_NAME]).getPath();

			if(fullName.at(0) != '/')
				fullName = "/" + fullName;

			if(fullName == meName)
			{
				found = true;
				break;
			}
		}

		if(found)
			findIter = m_meInfoMap.insert(MeInfoMap::value_type(meName, new MeInfo())).first;
		else
			return std::pair<size_t, bool>( 0 , false );
	}

	// add client and return (new) size of client list
	bool inserted = findIter->second->m_clientList.insert(clientID).second;
	size_t newSize = findIter->second->m_clientList.size();

	return std::pair<size_t, bool>( newSize , inserted );
}

//-------------------------------------------------------------------------------------------------

std::pair<size_t, bool> ModuleMeInfo::unsubscribe(int clientID, const std::string &meName)
{
	MeInfoMap::iterator findIter = m_meInfoMap.find(meName);

	if(findIter == m_meInfoMap.end())
		return std::pair<size_t, bool>( 0 , true );

	// remove client id and return (new) size of client list
	bool erased = ( findIter->second->m_clientList.erase(clientID) != 0 );
	size_t newSize = findIter->second->m_clientList.size();

	return std::pair<size_t, bool>( newSize , erased );
}

//-------------------------------------------------------------------------------------------------

bool ModuleMeInfo::unsubscribe(int clientID)
{
	bool unsubscribeAtLeastToOne = false;

	for(MeInfoMap::iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		if(iter->second->m_clientList.erase(clientID))
			unsubscribeAtLeastToOne = true;
	}

	return unsubscribeAtLeastToOne;
}

//-------------------------------------------------------------------------------------------------

size_t ModuleMeInfo::getNSubscribers(const std::string &meName) const
{
	MeInfoMap::const_iterator findIter = m_meInfoMap.find(meName);
	return ( ( findIter == m_meInfoMap.end() ) ? 0 : findIter->second->m_clientList.size() );
}

//-------------------------------------------------------------------------------------------------

size_t ModuleMeInfo::getNSubscribers() const
{
	std::set<int> clientList;

	for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		clientList.insert(iter->second->m_clientList.begin(), iter->second->m_clientList.end());
	}

	return clientList.size();
}

//-------------------------------------------------------------------------------------------------

std::set<int> ModuleMeInfo::getSubscribers(const std::string &meName) const
{
	MeInfoMap::const_iterator findIter = m_meInfoMap.find(meName);

	if(findIter != m_meInfoMap.end())
		return findIter->second->m_clientList;

	return std::set<int>();
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** Constructor
 */
ClientInfo::ClientInfo(int clientID) :
		m_clientID(clientID),
		m_updateMode(false),
		m_isModule(false),
		m_moduleName("")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

ClientInfo::ClientInfo(int clientId, const std::string &moduleName) :
		m_clientID(clientId),
		m_updateMode(false),
		m_isModule(true),
		m_moduleName(moduleName)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

const std::string &ClientInfo::getModuleName() const
{
	return m_moduleName;
}

//-------------------------------------------------------------------------------------------------

bool ClientInfo::isModule() const
{
	return m_isModule;
}

//-------------------------------------------------------------------------------------------------

int ClientInfo::getClientID() const
{
	return m_clientID;
}

//-------------------------------------------------------------------------------------------------

void ClientInfo::setUpdateMode(bool update)
{
	m_updateMode = update;
}

//-------------------------------------------------------------------------------------------------

bool ClientInfo::hasUpdateMode() const
{
	return m_updateMode;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

const std::string DQMMonitorElementCollector::m_emptyBufferStr = "EMPTY";

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollector::DQMMonitorElementCollector() :
		m_collectorName("DEFAULT"),
		m_collectorState(STOPPED_STATE),
		m_pMonitorElementNameListRpc(NULL),
		m_pMonitorElementCollectorInfoRpc(NULL),
		m_pInBuffer(NULL)
{
	m_pOutBuffer = new xdrstream::BufferDevice(5*1024*1024);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollector::~DQMMonitorElementCollector() 
{
	if(this->isRunning())
		this->stop();

	delete m_pOutBuffer;

	if(m_pInBuffer)
		delete m_pInBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::setCollectorName(const std::string &collectorName)
{
	if(isRunning())
		return STATUS_CODE_NOT_ALLOWED;

	m_collectorName = collectorName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementCollector::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::start()
{
	if(isRunning())
		return STATUS_CODE_SUCCESS;

	std::string baseName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
	std::stringstream ss;

	ss << baseName << "MONITOR_ELEMENT_NAME_LIST_RPC";
	m_pMonitorElementNameListRpc = new DQMMonitorElementNameListRpc((char *)ss.str().c_str(), this);

	ss.str("");
	ss << baseName << "COLLECTOR_INFO_RPC";
	m_pMonitorElementCollectorInfoRpc = new DQMMonitorElementCollectorInfoRpc((char *)ss.str().c_str(), this);

	// from modules
	ss.str("");
	ss << baseName << "COLLECT_ME_CMD";
	m_pCollectMeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "NOTIFY_WATCHED_ME_SVC";
	m_pNotifyWatchedMeService = new DimService((char *)ss.str().c_str(), "C",
			(void*) pMeCollectormptyBuffer, 5);



	// from clients
	ss.str("");
	ss << baseName << "AVAILABLE_ME_CMD";
	m_pAvailableMeListCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "QUERY_ME_CMD";
	m_pMeQueryCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "SET_UPDATE_MODE_CMD";
	m_pSetUpdateModeCommand = new DimCommand((char *)ss.str().c_str(), "I", this);

	ss.str("");
	ss << baseName << "SUBSCRIBE_CMD";
	m_pSubscribeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "UNSUBSCRIBE_CMD";
	m_pUnsubscribeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "SET_SUBSCRIPTION_CMD";
	m_pSetSubscriptionCommand = new DimCommand((char *)ss.str().c_str(), "C", this);

	ss.str("");
	ss << baseName << "STATS";
	m_pStatisticsService = new DQMStatisticsService(ss.str());

	ss.str("");
	ss << baseName << "ME_UPDATE_SVC";
	m_pMeUpdateService = new DimService((char *)ss.str().c_str(), "C",
			(void*) pMeCollectormptyBuffer, 5);


	m_collectorState = RUNNING_STATE;

	ss.str("");
	ss << baseName << "COLLECTOR_STATE_SVC";
	m_pCollectorStateService = new DimService((char *)ss.str().c_str(), m_collectorState);

	// for registration on dns ...
	sleep(1);

	// notify server running !
	LOG4CXX_INFO( dqmMainLogger , "Monitor element collector server started !" );
	m_pCollectorStateService->updateService(m_collectorState);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementCollector::stop()
{
	if(!isRunning())
		return STATUS_CODE_SUCCESS;

	delete m_pCollectMeCommand;
	delete m_pAvailableMeListCommand;
	delete m_pMeQueryCommand;
	delete m_pSetUpdateModeCommand;
	delete m_pSubscribeCommand;
	delete m_pUnsubscribeCommand;
	delete m_pSetSubscriptionCommand;

	delete m_pMonitorElementNameListRpc;
	delete m_pMonitorElementCollectorInfoRpc;
	delete m_pStatisticsService;
	delete m_pMeUpdateService;
	delete m_pNotifyWatchedMeService;

	m_collectorState = STOPPED_STATE;
	m_pCollectorStateService->updateService(m_collectorState);
	delete m_pCollectorStateService;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMState DQMMonitorElementCollector::getState() const
{
	return static_cast<DQMState>(m_collectorState);
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementCollector::isRunning() const
{
	return (m_collectorState == RUNNING_STATE);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::updateClients(const ClientUpdateMap &clientUpdateMap, bool forceUpdate)
{
	for(ClientUpdateMap::const_iterator iter = clientUpdateMap.begin(), endIter = clientUpdateMap.end() ;
			endIter != iter ; ++iter)
	{
		ClientMap::iterator clientIter = m_clientMap.find(iter->first);

		if(clientIter == m_clientMap.end())
		{
			LOG4CXX_WARN( dqmMainLogger , "Client no " << iter->first << " not registered. Skipping ..." );
			continue;
		}

		if(!clientIter->second.hasUpdateMode() && !forceUpdate)
		{
			LOG4CXX_DEBUG( dqmMainLogger , "Client no " << iter->first << " is not in update mode. Skipping ..." );
			continue;
		}

		LOG4CXX_DEBUG( dqmMainLogger , "Sending updates to client no " << iter->first );
		this->sendMeUpdate(clientIter->first);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::commandHandler()
{
	DimCommand *pReceivedCommand = getCommand();

	LOG4CXX_DEBUG( dqmMainLogger , "Received command : " << pReceivedCommand->getName() );

	// from modules
	if(pReceivedCommand == m_pCollectMeCommand)
	{
		this->handleMeCollectUpdate(pReceivedCommand);
	}
	else if(pReceivedCommand == m_pAvailableMeListCommand)
	{
		this->handleAvailableListUpdate(pReceivedCommand);
	}
	// from client side
	else if(pReceivedCommand == m_pMeQueryCommand)
	{
		this->handleMeQuery(getClientId(), m_pMeQueryCommand);
	}
	else if(pReceivedCommand == m_pSetUpdateModeCommand)
	{
		this->handleClientUpdateMode(getClientId(), static_cast<bool>(pReceivedCommand->getInt()));
	}
	else if(pReceivedCommand == m_pSubscribeCommand)
	{
		this->handleClientSubscription(getClientId(), pReceivedCommand);
	}
	else if(pReceivedCommand == m_pUnsubscribeCommand)
	{
		this->handleClientUnsubscription(getClientId(), pReceivedCommand);
	}
	else if(pReceivedCommand == m_pSetSubscriptionCommand)
	{
		this->handleClientRequestList(getClientId(), pReceivedCommand);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::clientExitHandler()
{
	int clientId = getClientId();
	this->deregisterClient(clientId);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleMeCollectUpdate(DimCommand *pCommand)
{
	try
	{
		char *pBuffer = static_cast<char *>(pCommand->getData());
		int bufferSize = pCommand->getSize();

		if(bufferSize == 0 || NULL == pBuffer)
		{
			LOG4CXX_WARN( dqmMainLogger , "Empty buffer, skipping packet ..." );
			throw StatusCodeException(STATUS_CODE_SUCCESS);
		}

		this->configureInBuffer( pBuffer , bufferSize );

		DQMPublication publication;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , publication ) )
		{
			LOG4CXX_ERROR( dqmMainLogger , "Couldn't read publication" );
			throw StatusCodeException(STATUS_CODE_FAILURE);
		}

		if(publication.empty())
		{
			LOG4CXX_ERROR( dqmMainLogger , "Empty publication, skipping packet ..." );
			throw StatusCodeException(STATUS_CODE_SUCCESS);
		}

		int nElements = 0;
		ClientUpdateMap clientUpdateMap;

		// update the monitor element with the ones received !
		// build the monitor element list to update for each client
		for(DQMPublication::iterator iter = publication.begin(), endIter = publication.end() ;
				endIter != iter ; ++iter)
		{
			ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(iter->first);

			if(findIter == m_moduleMeInfoMap.end())
				continue;

			// update monitor elements !
			for(DQMMonitorElementPtrList::iterator meIter = iter->second.begin(), meEndIter = iter->second.end() ;
					meEndIter != meIter ; ++meIter)
			{
				bool updated = findIter->second->updateMonitorElement(*meIter);

				nElements++;

				(*meIter)->setCollectorName(this->getCollectorName());

				// get the client ids that have subscribed to these elements
				std::string meFullName = ( (*meIter)->getPath() + (*meIter)->getName() ).getPath();

				if(meFullName.at(0) != '/')
					meFullName = "/" + meFullName;

				LOG4CXX_DEBUG( dqmMainLogger , "meFullName on collect : " << meFullName );
				std::set<int> clientIdSet = findIter->second->getSubscribers(meFullName);

				// add the monitor element entry into the update map
				for(std::set<int>::iterator cliIter = clientIdSet.begin(), cliEndIter = clientIdSet.end() ;
						cliEndIter != cliIter ; ++cliIter)
				{
					clientUpdateMap[*cliIter].insert(*meIter);
				}
			}
		}

		m_pStatisticsService->update(nElements);

		LOG4CXX_DEBUG( dqmMainLogger , "Received n elements : " << nElements << " from " << publication.size() << " modules" );
		this->updateClients(clientUpdateMap);
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "handleMeCollectUpdate(): Exception caught : " << exception.toString() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleAvailableListUpdate(DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
		{
			LOG4CXX_WARN( dqmMainLogger , "handleAvailableListUpdate(): invalid buffer");
			return;
		}

		this->configureInBuffer( pBuffer , bufferSize );

		// read the buffer
		std::string moduleName;
		if( xdrstream::XDR_SUCCESS != m_pInBuffer->read( & moduleName ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		LOG4CXX_DEBUG( dqmMainLogger , "handleAvailableListUpdate(): module name = " << moduleName );

		if(moduleName.empty())
			throw StatusCodeException(STATUS_CODE_FAILURE);

		DQMMonitorElementInfoList availableMeList;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , availableMeList ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// register client, even if maybe already registered
		bool newClient = this->registerClient(getClientId(), moduleName);

		// look for module entry to update
		ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(moduleName);

		// if not found, add the entry
		if(findIter == m_moduleMeInfoMap.end())
			findIter = m_moduleMeInfoMap.insert(ModuleMeInfoMap::value_type(moduleName, new ModuleMeInfo())).first;

		// update the entry
		findIter->second->setAvailableMeList(availableMeList);

		LOG4CXX_DEBUG( dqmMainLogger , "Received " << availableMeList.size() << " available element from module " << moduleName );

		if(newClient)
			this->notifyWatchedMe(moduleName);
	}
	catch(const StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "handleAvailableListUpdate(): Exception caught : " << exception.toString() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientUpdateMode(int clientId, bool updateMode)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter != m_clientMap.end())
	{
		if( ! findIter->second.hasUpdateMode() && updateMode)
		{
			LOG4CXX_INFO( dqmMainLogger , "Client no " << clientId << " update mode switched ON. Sending updates !" );
 			this->sendMeUpdate(clientId);
		}

		LOG4CXX_INFO( dqmMainLogger , "Client no " << clientId << " setting update mode to " << updateMode );
		findIter->second.setUpdateMode(updateMode);

		return;
	}

	LOG4CXX_WARN( dqmMainLogger , "Client no " << clientId << " not registered !" );
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientRequestList(int clientId, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		this->registerClient(clientId);
		this->configureInBuffer( pBuffer , bufferSize );

		DQMMonitorElementRequest request;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , request ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		for(DQMMonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
				endIter != iter ; ++iter)
		{
			ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);

			if(moduleIter == m_moduleMeInfoMap.end())
				continue;

			LOG4CXX_DEBUG( dqmMainLogger , "Found module : " << iter->first );

			// first unsubscribe to all elements
			moduleIter->second->unsubscribe(clientId);
			moduleIter->second->subscribe(clientId, iter->second);

			// in case the subscribed element is different
			this->notifyWatchedMe(iter->first);
		}
	}
	catch(const StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Exception caught : " << exception.toString() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleMeQuery(int clientId, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		this->configureInBuffer( pBuffer , bufferSize );
		DQMMonitorElementRequest request;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , request ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// if nothing specified in the request, just send updates
		if(request.empty())
		{
			LOG4CXX_INFO( dqmMainLogger , "Sending me updates from client query" );
			this->sendMeUpdate(clientId);
			return;
		}

		this->registerClient(clientId);

		StringSet updateModuleList;
		DQMPublication monitorElementPublication;

		LOG4CXX_DEBUG( dqmMainLogger , "Request size : " << request.size() );

		for(DQMMonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
				endIter != iter ; ++iter)
		{
			ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);

			if(moduleIter == m_moduleMeInfoMap.end())
				continue;

			LOG4CXX_DEBUG( dqmMainLogger , "Found module : " << iter->first );

			// subscribe to me if not done yet
			if( moduleIter->second->subscribe(clientId, iter->second).second )
			{
				LOG4CXX_DEBUG( dqmMainLogger , "New subscription for element : " << iter->second );
				updateModuleList.insert(iter->first);
			}
			else
			{
				LOG4CXX_DEBUG( dqmMainLogger , "Element : " << iter->second << " already subscribed !" );
			}

			// find the monitor element
			DQMMonitorElementPtr monitorElement = moduleIter->second->getMonitorElement(iter->second);

			if(NULL == monitorElement)
				continue;

			LOG4CXX_DEBUG( dqmMainLogger , "Element : " << iter->second << " found !" );
			monitorElementPublication[iter->first].push_back(monitorElement);
		}

		for(StringSet::iterator iter = updateModuleList.begin(), endIter = updateModuleList.end() ;
				endIter != iter ; ++iter)
		{
			LOG4CXX_DEBUG( dqmMainLogger , "Module " << *iter << " notified to send new me list !" );
			this->notifyWatchedMe(*iter);
		}

		if(monitorElementPublication.empty())
			return;

		m_pOutBuffer->reset();

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , monitorElementPublication ) )
			return;

		int clientIds[2];
		clientIds[0] = clientId;
		clientIds[1] = 0;

		LOG4CXX_DEBUG( dqmMainLogger , "Me update service called (on query) !" );
		m_pMeUpdateService->selectiveUpdateService((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() , &clientIds[0]);
	}
	catch(const StatusCodeException &exception)
	{
		LOG4CXX_WARN( dqmMainLogger , "handleMeQuery(): Exception caught : " << exception.toString() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientSubscription(int clientId, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		this->configureInBuffer( pBuffer , bufferSize );
		DQMMonitorElementRequest request;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , request ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// if nothing specified in the request, return
		if(request.empty())
		{
			LOG4CXX_DEBUG( dqmMainLogger , "No element to subscribe !" );
			return;
		}

		this->registerClient(clientId);

		StringSet updateModuleList;

		for(DQMMonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
				endIter != iter ; ++iter)
		{
			ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);

			if(moduleIter == m_moduleMeInfoMap.end())
				continue;

			if( moduleIter->second->subscribe(clientId, iter->second).second )
			{
				LOG4CXX_DEBUG( dqmMainLogger , "New subscription for element : " << iter->second );
				updateModuleList.insert(iter->first);
			}
		}

		for(StringSet::iterator iter = updateModuleList.begin(), endIter = updateModuleList.end() ;
				endIter != iter ; ++iter)
		{
			LOG4CXX_DEBUG( dqmMainLogger , "Module " << *iter << " notified to send new me list !" );
			this->notifyWatchedMe(*iter);
		}
	}
	catch(const StatusCodeException &exception)
	{
		LOG4CXX_WARN( dqmMainLogger , "handleClientSubscription(): Exception caught : " << exception.toString() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::handleClientUnsubscription(int clientId, DimCommand *pCommand)
{
	if(!this->isRunning())
		return;

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
		dqm_uint bufferSize = pCommand->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		this->configureInBuffer( pBuffer , bufferSize );
		DQMMonitorElementRequest request;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , request ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// if nothing specified in the request, return
		if(request.empty())
		{
			LOG4CXX_DEBUG( dqmMainLogger , "No element to unsubscribe !" );
			return;
		}

		this->registerClient(clientId);

		StringSet updateModuleList;

		for(DQMMonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
				endIter != iter ; ++iter)
		{
			ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);

			if(moduleIter == m_moduleMeInfoMap.end())
				continue;

			if( moduleIter->second->unsubscribe(clientId, iter->second).second )
			{
				LOG4CXX_DEBUG( dqmMainLogger , "Element un-subscribed : " << iter->second );
				updateModuleList.insert(iter->first);
			}
		}

		for(StringSet::iterator iter = updateModuleList.begin(), endIter = updateModuleList.end() ;
				endIter != iter ; ++iter)
		{
			LOG4CXX_DEBUG( dqmMainLogger , "Module " << *iter << " notified to send new me list !" );
			this->notifyWatchedMe(*iter);
		}
	}
	catch(const StatusCodeException &exception)
	{
		LOG4CXX_WARN( dqmMainLogger , "handleClientUnsubscription(): Exception caught : " << exception.toString() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::sendMeUpdate(int clientId)
{
	if(!this->isRunning())
		return;

	this->registerClient(clientId);

	DQMPublication monitorElementPublication;
	LOG4CXX_DEBUG( dqmMainLogger , "Building publication to send to client" );

	for(ModuleMeInfoMap::const_iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
			endIter != iter ; ++iter)
	{
		std::string moduleName = iter->first;

		DQMMonitorElementPtrList subscribedMeList = iter->second->getSubscribedMeList(clientId);

		if(subscribedMeList.empty())
			continue;

		LOG4CXX_DEBUG( dqmMainLogger , "Module " << moduleName << ", total me list = " << subscribedMeList.size() );

		monitorElementPublication.insert(DQMPublication::value_type(moduleName, subscribedMeList));
	}

	if(monitorElementPublication.empty())
	{
		LOG4CXX_DEBUG( dqmMainLogger , "Empty publication ! Nothing will be sent !" );
		return;
	}

	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , monitorElementPublication ) )
		return;

	int clientIds[2];
	clientIds[0] = clientId;
	clientIds[1] = 0;

	LOG4CXX_DEBUG( dqmMainLogger , "Me update service called (on update)!" );
	m_pMeUpdateService->selectiveUpdateService((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() , &clientIds[0]);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::notifyWatchedMe(const std::string &moduleName)
{
	int clientId = this->getModuleClientID(moduleName);

	if(0 == clientId)
		return;

	LOG4CXX_DEBUG( dqmMainLogger , "Notify watch me begin" );

	ModuleMeInfoMap::iterator moduleFindIter = m_moduleMeInfoMap.find(moduleName);

	if(moduleFindIter == m_moduleMeInfoMap.end())
		return;

	StringSet watchedMeList = moduleFindIter->second->getSubscribedList();
	m_pOutBuffer->reset();

	if( ! XDR_TESTBIT( DQMStreamingHelper::write( m_pOutBuffer , watchedMeList ) , xdrstream::XDR_SUCCESS ) )
	{
		LOG4CXX_DEBUG( dqmMainLogger , "Notify watch me. Couldn't write watched list" );
		return;
	}

	int clientIds[2];
	clientIds[0] = clientId;
	clientIds[1] = 0;

	LOG4CXX_DEBUG( dqmMainLogger , "Notify watch me. Client id " << clientId );

	m_pNotifyWatchedMeService->selectiveUpdateService( (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition(), &clientIds[0] );
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementCollector::registerClient(int clientId)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter != m_clientMap.end())
		return false;

	// just insert a new client
	m_clientMap.insert( ClientMap::value_type( clientId, ClientInfo(clientId) ) );
	DimServer::setClientExitHandler(clientId);

	return true;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementCollector::registerClient(int clientId, const std::string moduleName)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter != m_clientMap.end())
		return false;

	LOG4CXX_DEBUG( dqmMainLogger , "Registering module " << moduleName << " with client id " << clientId );

	// insert a new client
	m_clientMap.insert( ClientMap::value_type( clientId, ClientInfo(clientId, moduleName) ) );

	// create monitor element storage
	m_moduleMeInfoMap.insert( ModuleMeInfoMap::value_type( moduleName, new ModuleMeInfo() ) );

	DimServer::setClientExitHandler(clientId);

	return true;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementCollector::deregisterClient(int clientId)
{
	ClientMap::iterator findIter = m_clientMap.find(clientId);

	if(findIter == m_clientMap.end())
		return false;

	DimServer::clearClientExitHandler(clientId);

	// module client case
	if(findIter->second.isModule())
	{
		std::string moduleName = findIter->second.getModuleName();

		ModuleMeInfoMap::iterator moduleFindIter = m_moduleMeInfoMap.find(moduleName);

		if(moduleFindIter != m_moduleMeInfoMap.end())
		{
			delete moduleFindIter->second;
			m_moduleMeInfoMap.erase(moduleFindIter);
		}

		LOG4CXX_DEBUG( dqmMainLogger , "Deregistering module " << moduleName << " with client id " << clientId );
	}
	// monitor element client case
	else
	{
		// unsubscribe to all element that the client subscribed
		// this will update the list of watched monitor elements
		// We then have to notify modules that watched elements are not the same
		for(ModuleMeInfoMap::iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
				endIter != iter ; ++iter)
		{
			// this returns if at least one element has been removed
			// from the watched list. Use it to trigger update if necessary
			bool updateService = iter->second->unsubscribe(clientId);

			if(updateService)
				this->notifyWatchedMe(iter->first);
		}

		LOG4CXX_DEBUG( dqmMainLogger , "Registering me client " << clientId );
	}

	// finally remove the client from the map
	m_clientMap.erase(findIter);

	return true;
}

//-------------------------------------------------------------------------------------------------

int DQMMonitorElementCollector::getModuleClientID(const std::string &moduleName) const
{
	for(ClientMap::const_iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		if( ! iter->second.isModule() )
			continue;

		if( iter->second.getModuleName() == moduleName )
			return iter->first;
	}

	return 0;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollector::configureInBuffer( char *pBuffer , uint32_t bufferSize )
{
	if( ! m_pInBuffer )
		m_pInBuffer = new xdrstream::BufferDevice( pBuffer , bufferSize , false );
	else
		m_pInBuffer->setBuffer( pBuffer , bufferSize , false );

	m_pInBuffer->setOwner( false );
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementNameListRpc::DQMMonitorElementNameListRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNameListRpc::rpcHandler()
{
	try
	{
		if(!m_pCollector->isRunning())
			throw StatusCodeException(STATUS_CODE_FAILURE);

		dqm_char *pBuffer = static_cast<dqm_char *>(getData());
		dqm_uint bufferSize = getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		m_pCollector->configureInBuffer( pBuffer , bufferSize );
		DQMMonitorElementListNameRequest request;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pCollector->m_pInBuffer , request ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// transform module name to lower for easier comparison
		std::string requestModuleName = request[ DQMKey::MODULE_NAME ];
		std::string requestMonitorElementName = request[ DQMKey::ME_NAME ];
		std::string requestMonitorElementType = request[ DQMKey::ME_TYPE ];

		std::transform(requestModuleName.begin(), requestModuleName.end(), requestModuleName.begin(), ::tolower);
		std::transform(requestMonitorElementName.begin(), requestMonitorElementName.end(), requestMonitorElementName.begin(), ::tolower);

		DQMMonitorElementInfoList infoList;

		// loop over available contents and apply some filter to anwser the client query
		for(DQMMonitorElementCollector::ModuleMeInfoMap::const_iterator iter = m_pCollector->m_moduleMeInfoMap.begin(),
				endIter = m_pCollector->m_moduleMeInfoMap.end() ; endIter != iter ; ++iter)
		{
			std::string moduleName = iter->first;
			std::transform(moduleName.begin(), moduleName.end(), moduleName.begin(), ::tolower);

			// partial and lower case compare of module name
			if(moduleName.find(requestModuleName) == std::string::npos && !requestModuleName.empty())
				continue;

			std::vector<DQMMonitorElementInfo> availableMeList = iter->second->getAvailableMeList();

			for(std::vector<DQMMonitorElementInfo>::iterator meIter = availableMeList.begin(), meEndIter = availableMeList.end() ;
					meEndIter != meIter ; ++meIter)
			{
				std::string meName = (*meIter)[ DQMKey::ME_NAME ];
				std::transform(meName.begin(), meName.end(), meName.begin(), ::tolower);

				std::string path = (*meIter)[ DQMKey::ME_PATH ];
				std::transform(path.begin(), path.end(), path.begin(), ::tolower);

				std::string type = (*meIter)[ DQMKey::ME_TYPE ];

				// partial and lower case compare of me name
				if(meName.find(requestMonitorElementName) == std::string::npos && !requestMonitorElementName.empty())
					continue;

				// partial and lower case compare of path using me name
				if(path.find(requestMonitorElementName) == std::string::npos && !requestMonitorElementName.empty())
					continue;

				// compare me type
				if(type != requestMonitorElementType && monitorElementTypeToString(NO_ELEMENT_TYPE) != requestMonitorElementType)
					continue;

				infoList.push_back(*meIter);
			}
		}

		// serialize the packet
		m_pCollector->m_pOutBuffer->reset();

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pCollector->m_pOutBuffer , infoList ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		LOG4CXX_ERROR( dqmMainLogger , "DQMMonitorElementNameListRpc::rpcHandler() : Sending back request !" );

		// and set it as data to send back
		setData((void*) m_pCollector->m_pOutBuffer->getBuffer(), m_pCollector->m_pOutBuffer->getPosition());
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "DQMMonitorElementNameListRpc::rpcHandler() : Exception caught : " << exception.toString() );
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementCollectorInfoRpc::DQMMonitorElementCollectorInfoRpc(char *rpcName, DQMMonitorElementCollector *pCollector) :
		DimRpc(rpcName, "C", "C"),
		m_pCollector(pCollector)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementCollectorInfoRpc::rpcHandler()
{
	try
	{
		DQMHostInfo collectorInfo;
		DQMCoreTool::fillHostInfo(collectorInfo);

		// serialize the packet
		m_pCollector->m_pOutBuffer->reset();
		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pCollector->m_pOutBuffer , collectorInfo ) )
			return;

		// and set it as data to send back
		setData((void*) m_pCollector->m_pOutBuffer->getBuffer(), m_pCollector->m_pOutBuffer->getPosition());
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

} 

