  /// \file DQMDBInterface.cc
/*
 *
 * DQMDBInterface.cc source template automatically generated by a class generator
 * Creation date : lun. janv. 11 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/DQMDBInterface.h"

#include <fstream>

namespace dqm4hep
{

DQMDBInterface::DQMDBInterface() :
		m_pMySQL(NULL),
		m_isConnected(false)
{

}

//-------------------------------------------------------------------------------------------------

DQMDBInterface::DQMDBInterface(const std::string &host, const std::string &user, const std::string &password, const std::string &database) :
		m_pMySQL(NULL),
		m_isConnected(false)
{
	this->set(host, user, password, database);
	this->connect();
}

//-------------------------------------------------------------------------------------------------

DQMDBInterface::~DQMDBInterface()
{
	if(this->isConnected())
		this->disconnect();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::connect()
{
	if(this->isConnected())
		return STATUS_CODE_ALREADY_INITIALIZED;

	try
	{
		// create mysql instance
		m_pMySQL = mysql_init(NULL);

		if(!m_pMySQL)
		{
			streamlog_out(ERROR) << "Couldn't create mysql instance : " << mysql_error(m_pMySQL) << std::endl;
			throw StatusCodeException(STATUS_CODE_FAILURE);
		}

		// create connection to database
		if(NULL == mysql_real_connect(m_pMySQL, m_host.c_str(), m_user.c_str(), m_password.c_str(),
		                         NULL, 0, NULL, 0))
		{
			streamlog_out(ERROR) << "Couldn't initialize mysql connection : " << mysql_error(m_pMySQL) << std::endl;
			throw StatusCodeException(STATUS_CODE_FAILURE);
		}

		m_isConnected = true;

		// select data base
		std::stringstream query;
		query << "USE " << m_database << " ;";

		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(query.str()));
	}
	catch(const StatusCodeException &exception)
	{
		if(m_pMySQL)
			mysql_close(m_pMySQL);

		m_isConnected = false;

		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::disconnect()
{
	if(this->isConnected())
		return STATUS_CODE_UNCHANGED;

	if(m_pMySQL)
		mysql_close(m_pMySQL);

	m_isConnected = false;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::connect(const std::string &host, const std::string &user, const std::string &password, const std::string &database)
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->set(host, user, password, database));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->connect());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::set(const std::string &host, const std::string &user, const std::string &password, const std::string &database)
{
	if(this->isConnected())
		return STATUS_CODE_NOT_ALLOWED;

	m_host = host;
	m_user = user;
	m_password = password;
	m_database = database;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMDBInterface::getHost() const
{
	return m_host;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMDBInterface::getUser() const
{
	return m_user;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMDBInterface::getPassword() const
{
	return m_password;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMDBInterface::getDataBase() const
{
	return m_database;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::queryRaw(const std::string &query, void *&pResult)
{
	pResult = NULL;

	if(!this->isConnected())
		return STATUS_CODE_NOT_INITIALIZED;

	if(mysql_query(m_pMySQL, query.c_str()))
	{
		streamlog_out(ERROR) << "MySQL query failed : " << mysql_error(m_pMySQL) << std::endl;
		return STATUS_CODE_FAILURE;
	}

	MYSQL_RES *pMySQLResult = mysql_store_result(m_pMySQL);

	if(!pMySQLResult)
	{
		streamlog_out(ERROR) << "MySQL store result failed : " << mysql_error(m_pMySQL) << std::endl;
		return STATUS_CODE_FAILURE;
	}

	MYSQL_ROW row = mysql_fetch_row(pMySQLResult);

	pResult = (void *) row[0];

	mysql_free_result(pMySQLResult);

	if(NULL == pResult)
		return STATUS_CODE_FAILURE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::execute(const std::string &query)
{
	if(!this->isConnected())
		return STATUS_CODE_NOT_INITIALIZED;

	if(mysql_query(m_pMySQL, query.c_str()))
	{
		streamlog_out(ERROR) << "MySQL query failed : " << mysql_error(m_pMySQL) << std::endl;
		return STATUS_CODE_FAILURE;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMDBInterface::isConnected()
{
	return m_isConnected;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::queryConfigFileContent(const std::string &configFileName, std::string &fileContents)
{
	if(configFileName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	if(!this->isConnected())
		return STATUS_CODE_NOT_INITIALIZED;

	// select DQM4HEP database
	if(m_database != "DQM4HEP")
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute("USE DQM4HEP ;"));

	std::string queryUse = "USE " + m_database + " ;";

	std::stringstream query;
	query << "SELECT CONTENTS FROM CONFIG_FILES WHERE FILE_NAME=\"" << configFileName << "\" ;";

	void *pFileContent = NULL;
	StatusCode statusCode = this->queryRaw(query.str(), pFileContent);

	if(statusCode != STATUS_CODE_SUCCESS)
	{
		// select again the current database
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

		return statusCode;
	}

	fileContents = (char *) pFileContent;

	// select again the current database
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::queryConfigFileDescription(const std::string &configFileName, std::string &fileDescription)
{
	if(configFileName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	if(!this->isConnected())
		return STATUS_CODE_NOT_INITIALIZED;

	// select DQM4HEP database
	if(m_database != "DQM4HEP")
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute("USE DQM4HEP ;"));

	std::string queryUse = "USE " + m_database + " ;";

	std::stringstream query;
	query << "SELECT DESCRIPTION FROM CONFIG_FILES WHERE FILE_NAME=\"" << configFileName << "\" ;";

	void *pFileDescription = NULL;
	StatusCode statusCode = this->queryRaw(query.str(), pFileDescription);

	if(statusCode != STATUS_CODE_SUCCESS)
	{
		// select again the current database
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

		return statusCode;
	}

	fileDescription = (char *) pFileDescription;

	// select again the current database
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDBInterface::insertConfigFile(const std::string &localFileName, const std::string &fileNameEntry,
		const std::string &fileDescription, bool forceReplace)
{
	if(localFileName.empty() || fileNameEntry.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	if(!this->isConnected())
		return STATUS_CODE_NOT_INITIALIZED;

	std::ifstream ifile;
	ifile.open(localFileName.c_str(), std::ios::in);

	if(!ifile.is_open())
	{
		streamlog_out(ERROR) << "Couln't open file '" << localFileName << "' !" << std::endl;
		return STATUS_CODE_FAILURE;
	}

	std::string fileContents;

	while(!ifile.eof())
	{
		std::string str;
		getline(ifile, str);
		fileContents += str + "\n";
	}

	if(fileContents.empty())
		return STATUS_CODE_FAILURE;

	std::string queryUse = "USE " + m_database + " ;";

	// construct the mysql query
	std::stringstream query;

	if(forceReplace)
		query << "REPLACE ";
	else
		query << "INSERT ";

	query << "INTO CONFIG_FILES VALUES "
			<< "('" << fileNameEntry << "' ,"
			<< "'" << fileDescription << "' ,"
			<< "'" << fileContents << "') ;";

	// select DQM4HEP database
	if(m_database != "DQM4HEP")
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute("USE DQM4HEP ;"));

	StatusCode statusCode = this->execute(query.str());

	if(STATUS_CODE_SUCCESS != statusCode)
	{
		// select again the current database
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

		return statusCode;
	}

	// select again the current database
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

	return STATUS_CODE_SUCCESS;
}

} 

