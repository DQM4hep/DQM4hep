/// \file QualityTest.cc
/*
 *
 * QualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete, DESY
 */

// -- dqm4hep headers
#include "dqm4hep/QualityTest.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/MonitorElement.h"

namespace dqm4hep {

  namespace core {

    QualityTestReport::QualityTestReport() :
      m_qualityTestName(""),
      m_qualityTestType(""),
      m_qualityTestDescription(""),
      m_monitorElementName(""),
      m_monitorElementType(""),
      m_monitorElementPath(""),
      m_message(""),
      m_quality(0.f),
      m_isSuccessful(true),
      m_extraInfos(Json::objectValue)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    QualityTestReport::QualityTestReport(const QualityTestReport &qreport)
    {
      *this = qreport;
    }

    //-------------------------------------------------------------------------------------------------

    QualityTestReport &QualityTestReport::operator=(const QualityTestReport &qreport)
    {
      m_qualityTestName = qreport.m_qualityTestName;
      m_qualityTestType = qreport.m_qualityTestType;
      m_qualityTestDescription = qreport.m_qualityTestDescription;
      m_monitorElementName = qreport.m_monitorElementName;
      m_monitorElementType = qreport.m_monitorElementType;
      m_monitorElementPath = qreport.m_monitorElementPath;
      m_message = qreport.m_message;
      m_quality = qreport.m_quality;
      m_isSuccessful = qreport.m_isSuccessful;
      m_extraInfos = qreport.m_extraInfos;

      return *this;
    }

    //-------------------------------------------------------------------------------------------------

    void QualityTestReport::toJson(Json::Value &value) const
    {
      value["qualityTestType"] = m_qualityTestType;
      value["qualityTestName"] = m_qualityTestName;
      value["qualityTestDescription"] = m_qualityTestDescription;
      value["monitorElementName"] = m_monitorElementName;
      value["monitorElementType"] = m_monitorElementType;
      value["monitorElementPath"] = m_monitorElementPath;
      value["message"] = m_message;
      value["quality"] = static_cast<int>(m_quality);
      value["successful"] = m_isSuccessful;
      value["extra"] = m_extraInfos;
    }

    //-------------------------------------------------------------------------------------------------

    void QualityTestReport::fromJson(const Json::Value &value)
    {
      m_qualityTestType = value.get("qualityTestType", m_qualityTestType).asString();
      m_qualityTestName = value.get("qualityTestName", m_qualityTestName).asString();
      m_qualityTestDescription = value.get("qualityTestDescription", m_qualityTestDescription).asString();
      m_monitorElementType = value.get("monitorElementType", m_monitorElementType).asString();
      m_monitorElementName = value.get("monitorElementName", m_monitorElementName).asString();
      m_monitorElementPath = value.get("monitorElementPath", m_monitorElementPath).asString();
      m_message = value.get("message", m_message).asString();
      m_quality = value.get("quality", m_quality).asFloat();
      m_isSuccessful = value.get("successful", m_isSuccessful).asBool();
      m_extraInfos = value.get("extra", m_extraInfos);
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    QReportStorage::QReportStorage() :
      m_reports()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    void QReportStorage::addReport(const QReport &report, bool warnOnReplace)
    {
      const std::string &path(report.m_monitorElementPath);
      const std::string &name(report.m_monitorElementName);
      const std::string &qtname(report.m_qualityTestName);

      if(!warnOnReplace)
      {
        QReportContainer::key_type key(path, name);
        m_reports[key][qtname] = report;
      }
      else
      {
        QReportContainer::key_type key(path, name);
        auto iter1 = m_reports.find(key);

        if(m_reports.end() == iter1)
          iter1 = m_reports.insert(QReportContainer::value_type(key, QReportMap())).first;

        auto iter2 = iter1->second.find(qtname);

        if(iter1->second.end() == iter2)
        {
          iter2 = iter1->second.insert(QReportMap::value_type(qtname, report)).first;
        }
        else
        {
          dqm_warning( "QReportStorage::addReport: Replacing qreport path '{0}', name '{1}', qtest '{2}'", path, name, qtname );
          iter2->second = report;
        }
      }
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QReportStorage::report(const std::string &path, const std::string &name, const std::string &qualityTestName, QReport &report)
    {
      QReportContainer::key_type key(path, name);
      auto findIter = m_reports.find(key);

      if(m_reports.end() == findIter)
        return STATUS_CODE_NOT_FOUND;

      auto findIter2 = findIter->second.find(qualityTestName);

      if(findIter->second.end() == findIter2)
        return STATUS_CODE_NOT_FOUND;

      report = findIter2->second;
      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QReportStorage::reports(const std::string &path, const std::string &name, QReportMap &reports)
    {
      QReportContainer::key_type key(path, name);
      auto findIter = m_reports.find(key);

      if(m_reports.end() == findIter)
        return STATUS_CODE_NOT_FOUND;

      reports.insert(findIter->second.begin(), findIter->second.end());
      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QReportStorage::reportsQualityHigher(const std::string &path, const std::string &name, float qlimit, QReportMap &reports)
    {
      if(0.f < qlimit || qlimit > 1.f)
        return STATUS_CODE_OUT_OF_RANGE;

      QReportContainer::key_type key(path, name);
      auto findIter = m_reports.find(key);

      if(m_reports.end() == findIter)
        return STATUS_CODE_NOT_FOUND;

      for(auto qtest : findIter->second)
      {
        if(qtest.second.m_quality >= qlimit)
        {
          reports.insert(QReportMap::value_type(qtest.first, qtest.second));
        }
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QReportStorage::reportsQualityLower(const std::string &path, const std::string &name, float qlimit, QReportMap &reports)
    {
      if(0.f < qlimit || qlimit > 1.f)
        return STATUS_CODE_OUT_OF_RANGE;

      QReportContainer::key_type key(path, name);
      auto findIter = m_reports.find(key);

      if(m_reports.end() == findIter)
        return STATUS_CODE_NOT_FOUND;

      for(auto qtest : findIter->second)
      {
        if(qtest.second.m_quality <= qlimit)
        {
          reports.insert(QReportMap::value_type(qtest.first, qtest.second));
        }
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const QReportContainer &QReportStorage::reports()
    {
      return m_reports;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QReportStorage::reportsQualityHigher(float qlimit, QReportContainer &reports)
    {
      if(0.f < qlimit || qlimit > 1.f)
        return STATUS_CODE_OUT_OF_RANGE;

      for(auto iter1 : m_reports)
      {
        QReportMap reportMap;

        for(auto iter2 : iter1.second)
        {
          if(iter2.second.m_quality >= qlimit)
          {
            reportMap.insert(QReportMap::value_type(iter2.first, iter2.second));
          }
        }

        if(reportMap.empty())
          continue;

        m_reports.insert(QReportContainer::value_type(iter1.first, reportMap));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QReportStorage::reportsQualityLower(float qlimit, QReportContainer &reports)
    {
      if(0.f < qlimit || qlimit > 1.f)
        return STATUS_CODE_OUT_OF_RANGE;

      for(auto iter1 : m_reports)
      {
        QReportMap reportMap;

        for(auto iter2 : iter1.second)
        {
          if(iter2.second.m_quality <= qlimit)
          {
            reportMap.insert(QReportMap::value_type(iter2.first, iter2.second));
          }
        }

        if(reportMap.empty())
          continue;

        m_reports.insert(QReportContainer::value_type(iter1.first, reportMap));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void QReportStorage::clear()
    {
      m_reports.clear();
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    QualityTest::QualityTest(const std::string &type, const std::string &name) :
      m_type(type),
	    m_name(name),
      m_description("")
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    QualityTest::~QualityTest()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &QualityTest::type() const
    {
      return m_type;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &QualityTest::name() const
    {
      return m_name;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &QualityTest::description() const
    {
      return m_description;
    }

    //-------------------------------------------------------------------------------------------------

    void QualityTest::run(MonitorElement *pMonitorElement, QualityTestReport &report)
    {
      this->fillBasicInfo(pMonitorElement, report);

      if(!this->canRun(pMonitorElement))
      {
        report.m_message = "Couldn't run quality test: canRun() failed";
        report.m_quality = 0.f;
        report.m_isSuccessful = false;
        return;
      }

      try
      {
        THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->userRun(pMonitorElement, report));
      }
      catch(StatusCodeException &exception)
      {
        const std::string message("Caught StatusCodeException while run QTest: " + exception.toString());

        if(!report.m_message.empty())
          report.m_message + " " + message;
        else
          report.m_message = message;

        report.m_quality = 0.f;
        report.m_isSuccessful = false;
      }
      catch(...)
      {
        const std::string message("Caught unknown exception while run QTest");

        if(!report.m_message.empty())
          report.m_message + " " + message;
        else
          report.m_message = message;

        report.m_quality = 0.f;
        report.m_isSuccessful = false;
      }
    }

    //-------------------------------------------------------------------------------------------------

    void QualityTest::fillBasicInfo(MonitorElement *pMonitorElement, QualityTestReport &report) const
    {
      report.m_qualityTestName = this->name();
      report.m_qualityTestType = this->type();
      report.m_qualityTestDescription = this->description();
      report.m_monitorElementType = pMonitorElement->type();
      report.m_monitorElementName = pMonitorElement->name();
      report.m_monitorElementPath = pMonitorElement->path();
      report.m_quality = 0.f;
      report.m_message = "";
      report.m_isSuccessful = false;
      report.m_extraInfos.clear();
    }

  }

}
