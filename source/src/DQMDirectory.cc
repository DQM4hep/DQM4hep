  /// \file DQMDirectory.cc
/*
 *
 * DQMDirectory.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMDirectory.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMCoreTool.h"

namespace dqm4hep
{

DQMDirectory::DQMDirectory() :
	m_name(""),
	m_pParentDir(NULL)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMDirectory::DQMDirectory(const std::string &name, DQMDirectory *pParentDir) :
	m_name(name),
	m_pParentDir(pParentDir)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMDirectory::~DQMDirectory()
{
	clear();
}

//-------------------------------------------------------------------------------------------------

void DQMDirectory::ls(bool recursive) const
{
	int depth = 0;
	std::string parentDirName = m_pParentDir == NULL ? "\"\"" : m_pParentDir->m_name;

	LOG4CXX_INFO( dqmMainLogger , "Directory " << m_name << " (parent = " << parentDirName << ") :" );

	// print contents first
	for(DQMMonitorElementPtrList::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		LOG4CXX_INFO( dqmMainLogger , " [ME]  " << (*iter)->getName() );
	}

	// print sub-directories
	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;

		if(recursive)
		{
			pDirectory->ls(depth+1);
		}
		else
		{
			LOG4CXX_INFO( dqmMainLogger , " [DIR] " << pDirectory->m_name );
		}
	}

	LOG4CXX_INFO( dqmMainLogger , "" );
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMDirectory::getName() const
{
	return m_name;
}

//-------------------------------------------------------------------------------------------------

DQMDirectory *DQMDirectory::getParentDir() const
{
	return m_pParentDir;
}

//-------------------------------------------------------------------------------------------------

const std::vector<DQMDirectory*> &DQMDirectory::getSubDirList() const
{
	return m_directoryList;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::mkdir(const std::string &dirName)
{
	if(containsDir(dirName))
		return STATUS_CODE_ALREADY_PRESENT;

	if(dirName.find("/") != std::string::npos || DQMCoreTool::containsSpecialCharacters(dirName) || dirName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	DQMDirectory *pNewDirectory = new DQMDirectory(dirName, this);
	m_directoryList.push_back(pNewDirectory);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::containsDir(const std::string &dirName) const
{
	if(dirName.find("/") != std::string::npos || DQMCoreTool::containsSpecialCharacters(dirName) || dirName.empty())
		return false;

	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;

		if(pDirectory->getName() == dirName)
			return true;
	}

	return false;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::findDir(const std::string &dirName, DQMDirectory *&pDirectory) const
{
	pDirectory = NULL;

	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDir = *iter;

		if(pDir->getName() == dirName)
		{
			pDirectory = pDir;
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::addMonitorElement(const DQMMonitorElementPtr &monitorElement)
{
	if(NULL == monitorElement)
		return STATUS_CODE_INVALID_PTR;

	if(containsMonitorElement(monitorElement))
		return STATUS_CODE_ALREADY_PRESENT;

	m_contentsList.push_back(monitorElement);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::findMonitorElement(const std::string &name, DQMMonitorElementPtr &monitorElement) const
{
	monitorElement = NULL;

	// print contents first
	for(DQMMonitorElementPtrList::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		if((*iter)->getName() == name)
		{
			monitorElement = *iter;
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::containsMonitorElement(const DQMMonitorElementPtr &monitorElement) const
{
	return containsMonitorElement(monitorElement->getName());
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::containsMonitorElement(const std::string &monitorElementName) const
{
	DQMMonitorElementPtr monitorElement;
	return findMonitorElement(monitorElementName, monitorElement) == STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::removeMonitorElement(const DQMMonitorElementPtr &monitorElement)
{
	return removeMonitorElement(monitorElement->getName());
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::removeMonitorElement(const std::string &monitorElementName)
{
	for(DQMMonitorElementPtrList::iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
	{
		if((*iter)->getName() == monitorElementName)
		{
			m_contentsList.erase(iter);
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

const DQMMonitorElementPtrList &DQMDirectory::getMonitorElementList() const
{
	return m_contentsList;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::removeDir(const std::string &dirName)
{
	for(std::vector<DQMDirectory*>::iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;

		if(pDirectory->getName() == dirName)
		{
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->clear());
			delete pDirectory;
			m_directoryList.erase(iter);

			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDirectory::clear()
{
	m_contentsList.clear();

	for(std::vector<DQMDirectory*>::iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
	{
		DQMDirectory *pDirectory = *iter;
		// clear recursively the sub dir
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->clear());
		// delete ptr
		delete pDirectory;
	}

	m_directoryList.clear();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMPath DQMDirectory::getFullPathName() const
{
	DQMPath fullPath = this->getName();
	const DQMDirectory *pDir = this;

	while(1)
	{
		const DQMDirectory *pParentDir = pDir->getParentDir();

		if(NULL != pParentDir)
		{
			fullPath = pParentDir->getName() + fullPath;
			pDir = pParentDir;
		}
		else
			break;
	}

	return fullPath;
}

//-------------------------------------------------------------------------------------------------

void DQMDirectory::ls(int depth) const
{
	std::string parentDirName = m_pParentDir == NULL ? "\"\"" : m_pParentDir->m_name;

	LOG4CXX_INFO( dqmMainLogger , std::string(depth*3, ' ') << "Directory " << m_name << " (parent = " << parentDirName << ") :" );

	// print contents first
	for(DQMMonitorElementPtrList::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
			endIter != iter ; ++iter)
		LOG4CXX_INFO( dqmMainLogger , std::string(depth*3, ' ') << " [ME]  " << (*iter)->getName() );

	// print sub dirs
	for(std::vector<DQMDirectory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
			endIter != iter ; ++iter)
		(*iter)->ls(depth+1);
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::isRootDir() const
{
	return (m_pParentDir == NULL);
}

//-------------------------------------------------------------------------------------------------

bool DQMDirectory::isEmpty() const
{
	return (m_directoryList.empty() && m_contentsList.empty());
}

//-------------------------------------------------------------------------------------------------

} 

