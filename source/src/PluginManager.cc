/*
 *
 * DQMPluginManager.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/PluginManager.h"
#include "dqm4hep/Logging.h"

// -- std headers
#include <dlfcn.h>
#include <cstdlib>

namespace dqm4hep {

  namespace core {

    PluginManager::PluginManager()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    PluginManager::~PluginManager()
    {
      for( PluginMap::const_iterator iter = m_pluginMap.begin(), endIter = m_pluginMap.end() ;
          endIter != iter ; ++iter )
      {
        delete iter->second;
      }

      m_pluginMap.clear();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::loadLibraries()
    {
      // get the environment plug-in dll variable
      char *pPluginDllEnv = getenv( "DQM4HEP_PLUGIN_DLL" );

      if( pPluginDllEnv == 0 )
      {
        LOG4CXX_WARN( dqmMainLogger , "Environment variable DQM4HEP_PLUGIN_DLL not found ! \n"
            "Set it before loading shared libraries. \n"
            "Example : export DQM4HEP_PLUGIN_DLL=libPlugin1.so:libPlugin2.so" );

        return STATUS_CODE_SUCCESS;
      }

      // split the string into a list
      std::string libraryConcatenateList( pPluginDllEnv );
      StringVector libraryList;

      DQM4HEP::tokenize( libraryConcatenateList, libraryList, ":" );

      // load the shared libraries
      return this->loadLibraries( libraryList );
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::loadLibraries( const StringVector &libraryNameList )
    {
      for( StringVector::const_iterator iter = libraryNameList.begin(), endIter = libraryNameList.end() ;
          endIter != iter ; ++iter )
      {
        RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->loadLibrary( *iter ) );
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::loadLibrary( const std::string &libraryName )
    {
      size_t idx = libraryName.find_last_of( "/" );

      // the library basename, i.e. /path/to/libBlah.so --> libBlah.so
      std::string libBaseName( libraryName.substr( idx + 1 ) );

      char *real_path = realpath( libraryName.c_str(), NULL );

      if( NULL != real_path )
      {
        LOG4CXX_INFO( dqmMainLogger , "<!-- Loading shared library : " << real_path << " ("<< libBaseName << ")-->" );

        // use real_path
        free( real_path );
      }
      else
      {
        LOG4CXX_INFO( dqmMainLogger , "<!-- Loading shared library : " << libraryName << " ("<< libBaseName << ")-->" );
      }

      void *pLibPointer = dlopen( libraryName.c_str(), RTLD_LAZY | RTLD_GLOBAL );

      if( pLibPointer == 0 )
      {
        LOG4CXX_ERROR( dqmMainLogger , "<!-- ERROR loading shared library : " << libraryName << "\n"
            << "    ->    "   << dlerror() << " -->" );

        return STATUS_CODE_FAILURE;
      }
      else
        return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    Plugin *PluginManager::getPlugin( const std::string &pluginName ) const
    {
      if( ! isPluginRegistered( pluginName ) )
        return 0;

      return m_pluginMap.find( pluginName )->second;
    }

    //-------------------------------------------------------------------------------------------------

    bool PluginManager::isPluginRegistered( const std::string &pluginName ) const
    {
      return ( m_pluginMap.find( pluginName ) != m_pluginMap.end() );
    }

    //-------------------------------------------------------------------------------------------------

    StringVector PluginManager::getPluginNameList() const
    {
      StringVector pluginNameList;

      for( PluginMap::const_iterator iter = m_pluginMap.begin(), endIter = m_pluginMap.end() ;
          endIter != iter ; ++iter )
      {
        pluginNameList.push_back( iter->first );
      }

      return pluginNameList;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::registerPlugin( Plugin *pPlugin )
    {
      // null ptr case
      if( NULL == pPlugin )
        return STATUS_CODE_INVALID_PTR;

      // check if the plug is already registered
      if( isPluginRegistered( pPlugin->getPluginName() ) )
      {
        delete pPlugin;
        pPlugin = NULL;
        return STATUS_CODE_ALREADY_PRESENT;
      }

      // try to register it
      if( ! m_pluginMap.insert( PluginMap::value_type( pPlugin->getPluginName(), pPlugin ) ).second )
      {
        delete pPlugin;
        pPlugin = NULL;

        return STATUS_CODE_FAILURE;
      }

      return STATUS_CODE_SUCCESS;
    }

  }

} 

