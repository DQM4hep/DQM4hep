/// \file DQMDBInterface.cc
/*
 *
 * DQMDBInterface.cc source template automatically generated by a class generator
 * Creation date : lun. janv. 11 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/DBInterface.h"

#include <fstream>

namespace dqm4hep {

  namespace core {

    DBInterface::DBInterface() :
        m_pMySQL(NULL),
        m_isConnected(false)
    {

    }

    //-------------------------------------------------------------------------------------------------

    DBInterface::DBInterface(const std::string &host, const std::string &user, const std::string &password, const std::string &database) :
		    m_pMySQL(NULL),
		    m_isConnected(false)
    {
      this->set(host, user, password, database);
      this->connect();
    }

    //-------------------------------------------------------------------------------------------------

    DBInterface::~DBInterface()
    {
      if(this->isConnected())
        this->disconnect();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::connect()
    {
      if(this->isConnected())
        return STATUS_CODE_ALREADY_INITIALIZED;

      try
      {
        // create mysql instance
        m_pMySQL = mysql_init(NULL);

        if(!m_pMySQL)
        {
          LOG4CXX_ERROR( dqmMainLogger , "Couldn't create mysql instance : " << mysql_error(m_pMySQL) );
          throw StatusCodeException(STATUS_CODE_FAILURE);
        }

        // create connection to database
        if(NULL == mysql_real_connect(m_pMySQL, m_host.c_str(), m_user.c_str(), m_password.c_str(),
            NULL, 0, NULL, 0))
        {
          LOG4CXX_ERROR( dqmMainLogger , "Couldn't initialize mysql connection : " << mysql_error(m_pMySQL) );
          throw StatusCodeException(STATUS_CODE_FAILURE);
        }

        m_isConnected = true;

        // select data base
        std::stringstream query;
        query << "USE " << m_database << " ;";

        THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(query.str()));
      }
      catch(const StatusCodeException &exception)
      {
        if(m_pMySQL)
          mysql_close(m_pMySQL);

        m_isConnected = false;

        return exception.getStatusCode();
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::disconnect()
    {
      if(this->isConnected())
        return STATUS_CODE_UNCHANGED;

      if(m_pMySQL)
        mysql_close(m_pMySQL);

      m_isConnected = false;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::connect(const std::string &host, const std::string &user, const std::string &password, const std::string &database)
    {
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->set(host, user, password, database));
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->connect());

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::set(const std::string &host, const std::string &user, const std::string &password, const std::string &database)
    {
      if(this->isConnected())
        return STATUS_CODE_NOT_ALLOWED;

      m_host = host;
      m_user = user;
      m_password = password;
      m_database = database;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &DBInterface::getHost() const
    {
      return m_host;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &DBInterface::getUser() const
    {
      return m_user;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &DBInterface::getPassword() const
    {
      return m_password;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &DBInterface::getDataBase() const
    {
      return m_database;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::queryRaw(const std::string &query, void *&pResult)
    {
      pResult = NULL;

      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      if(mysql_query(m_pMySQL, query.c_str()))
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL query failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_RES *pMySQLResult = mysql_store_result(m_pMySQL);

      if(!pMySQLResult)
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL store result failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_ROW row = mysql_fetch_row(pMySQLResult);

      pResult = (void *) row[0];

      mysql_free_result(pMySQLResult);

      if(NULL == pResult)
        return STATUS_CODE_FAILURE;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::execute(const std::string &query)
    {
      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      if(mysql_query(m_pMySQL, query.c_str()))
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL query failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    bool DBInterface::isConnected()
    {
      return m_isConnected;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::queryConfigFileContent(const std::string &configFileName, std::string &fileContents)
    {
      if(configFileName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      // select DQM4HEP database
      if(m_database != "DQM4HEP")
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute("USE DQM4HEP ;"));

      std::string queryUse = "USE " + m_database + " ;";

      std::stringstream query;
      query << "SELECT CONTENTS FROM CONFIG_FILES WHERE FILE_NAME=\"" << configFileName << "\" ;";

      void *pFileContent = NULL;
      StatusCode statusCode = this->queryRaw(query.str(), pFileContent);

      if(statusCode != STATUS_CODE_SUCCESS)
      {
        // select again the current database
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

        return statusCode;
      }

      fileContents = (char *) pFileContent;

      // select again the current database
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::queryConfigFileDescription(const std::string &configFileName, std::string &fileDescription)
    {
      if(configFileName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      // select DQM4HEP database
      if(m_database != "DQM4HEP")
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute("USE DQM4HEP ;"));

      std::string queryUse = "USE " + m_database + " ;";

      std::stringstream query;
      query << "SELECT DESCRIPTION FROM CONFIG_FILES WHERE FILE_NAME=\"" << configFileName << "\" ;";

      void *pFileDescription = NULL;
      StatusCode statusCode = this->queryRaw(query.str(), pFileDescription);

      if(statusCode != STATUS_CODE_SUCCESS)
      {
        // select again the current database
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

        return statusCode;
      }

      fileDescription = (char *) pFileDescription;

      // select again the current database
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DBInterface::insertConfigFile(const std::string &localFileName, const std::string &fileNameEntry,
        const std::string &fileDescription, bool forceReplace)
    {
      if(localFileName.empty() || fileNameEntry.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      std::ifstream ifile;
      ifile.open(localFileName.c_str(), std::ios::in);

      if(!ifile.is_open())
      {
        LOG4CXX_ERROR( dqmMainLogger , "Couln't open file '" << localFileName << "' !" );
        return STATUS_CODE_FAILURE;
      }

      std::string fileContents;

      while(!ifile.eof())
      {
        std::string str;
        getline(ifile, str);
        fileContents += str + "\n";
      }

      if(fileContents.empty())
        return STATUS_CODE_FAILURE;

      std::string queryUse = "USE " + m_database + " ;";

      // construct the mysql query
      std::stringstream query;

      if(forceReplace)
        query << "REPLACE ";
      else
        query << "INSERT ";

      query << "INTO CONFIG_FILES VALUES "
          << "('" << fileNameEntry << "' ,"
          << "'" << fileDescription << "' ,"
          << "'" << fileContents << "') ;";

      // select DQM4HEP database
      if(m_database != "DQM4HEP")
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute("USE DQM4HEP ;"));

      StatusCode statusCode = this->execute(query.str());

      if(STATUS_CODE_SUCCESS != statusCode)
      {
        // select again the current database
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

        return statusCode;
      }

      // select again the current database
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->execute(queryUse));

      return STATUS_CODE_SUCCESS;
    }

  }

}

