/// \file RequestHandler.cc
/*
 *
 * RequestHandler.cc source template automatically generated by a class generator
 * Creation date : sam. dï¿½c. 3 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/RequestHandler.h"

namespace dqm4hep {

  namespace net {

    // namespace experimental {

      RequestHandler::~RequestHandler()
      {
        this->stopHandlingRequest();
      }

      //-------------------------------------------------------------------------------------------------

      const std::string &RequestHandler::name() const
      {
        return m_name;
      }

      //-------------------------------------------------------------------------------------------------

      Server *RequestHandler::server() const
      {
        return m_pServer;
      }

      //-------------------------------------------------------------------------------------------------

      void RequestHandler::startHandlingRequest()
      {
        if(!this->isHandlingRequest())
        {
          m_pRpc = new Rpc(this);
        }
      }

      //-------------------------------------------------------------------------------------------------

      void RequestHandler::stopHandlingRequest()
      {
        if(this->isHandlingRequest())
        {
          delete m_pRpc;
          m_pRpc = nullptr;
        }
      }

      //-------------------------------------------------------------------------------------------------

      bool RequestHandler::isHandlingRequest() const
      {
        return (m_pRpc != nullptr);
      }

      //-------------------------------------------------------------------------------------------------

      RequestHandler::RequestSignal &RequestHandler::onRequest()
      {
        return m_requestSignal;
      }

      //-------------------------------------------------------------------------------------------------

      void RequestHandler::handleRequest(const Buffer &request, Buffer &response)
      {
        m_requestSignal.process(request, response);
      }

      //-------------------------------------------------------------------------------------------------
      //-------------------------------------------------------------------------------------------------

      RequestHandler::Rpc::Rpc(RequestHandler *pHandler) :
        DimRpc((char*)pHandler->name().c_str(), "C", "C"),
        m_pHandler(pHandler)
      {
        /* nop */
      }

      //-------------------------------------------------------------------------------------------------

      void RequestHandler::Rpc::rpcHandler()
      {
        char *data = (char*)this->getData();
        int size = this->getSize();
        Buffer request;

        if(nullptr != data && size != 0)
          request.adopt(data, size);

        Buffer response;
        m_pHandler->handleRequest(request, response);
        this->setData((void*)response.begin(), response.size());
      }

      //-------------------------------------------------------------------------------------------------
      //-------------------------------------------------------------------------------------------------

      CommandHandler::CommandHandler(Server *pServer, const std::string &name) :
        m_name(name),
        m_pServer(pServer),
        m_pCommand(nullptr)
      {

      }

      //-------------------------------------------------------------------------------------------------

      CommandHandler::~CommandHandler()
      {
        this->stopHandlingCommands();
      }

      //-------------------------------------------------------------------------------------------------

      const std::string &CommandHandler::name() const
      {
        return m_name;
      }

      //-------------------------------------------------------------------------------------------------

      Server *CommandHandler::server() const
      {
        return m_pServer;
      }

      //-------------------------------------------------------------------------------------------------

      void CommandHandler::startHandlingCommands()
      {
        if(!this->isHandlingCommands())
        {
          m_pCommand = new Command(this);
        }
      }

      //-------------------------------------------------------------------------------------------------

      void CommandHandler::stopHandlingCommands()
      {
        if(this->isHandlingCommands())
        {
          delete m_pCommand;
          m_pCommand = nullptr;
        }
      }

      //-------------------------------------------------------------------------------------------------

      bool CommandHandler::isHandlingCommands() const
      {
        return (m_pCommand != nullptr);
      }

      //-------------------------------------------------------------------------------------------------

      CommandHandler::CommandSignal &CommandHandler::onCommand()
      {
        return m_commandSignal;
      }

      //-------------------------------------------------------------------------------------------------

      void CommandHandler::handleCommand(const Buffer &command)
      {
        m_commandSignal.process(command);
      }

      //------------------------------------------------------------------------------------------------
      //--------------------------------------------------------------------------------------------------

      CommandHandler::Command::Command(CommandHandler *pHandler) :
        DimCommand((char*)pHandler->name().c_str(), "C"),
        m_pHandler(pHandler)
      {
        /* nop */
      }

      //-------------------------------------------------------------------------------------------------

      void CommandHandler::Command::commandHandler()
      {
        char *data = (char*)this->getData();
        int size = this->getSize();

        if(nullptr == data || size == 0)
          return;

        Buffer command;
        command.adopt(data, size);
        m_pHandler->handleCommand(command);
      }

  }

}
