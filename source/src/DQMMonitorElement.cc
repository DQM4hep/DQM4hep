  /// \file DQMMonitorElement.cc
/*
 *
 * DQMMonitorElement.cc source template automatically generated by a class generator
 * Creation date : jeu. sept. 4 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Ete Remi
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMLogging.h"

// -- root headers
#include "TObject.h"
#include "TNamed.h"
#include "TBufferFile.h"
#include "TH1.h"
#include "TH1F.h"
#include "TH1I.h"
#include "TH1S.h"
#include "TH1C.h"
#include "TH2.h"
#include "TH2F.h"
#include "TH2I.h"
#include "TH2S.h"
#include "TH2C.h"
#include "TProfile.h"
#include "TProfile2D.h"
#include "TAxis.h"
#include "TPad.h"

templateClassImp(dqm4hep::TScalarObject)
ClassImp(dqm4hep::TDynamicGraph)

namespace dqm4hep
{

//-------------------------------------------------------------------------------------------------

DQMMonitorElement::DQMMonitorElement(DQMMonitorElementType type,
		const std::string &name, const std::string &title,
		const std::string &moduleName) :
		m_type(type),
		m_name(name),
		m_title(title),
		m_moduleName(moduleName),
		m_description(""),
		m_drawOption(""),
		m_quality(NO_QUALITY),
		m_resetPolicy(END_OF_RUN_RESET_POLICY),
		m_runNumber(0),
		m_toPublish(true),
		m_pObject(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement::DQMMonitorElement(TObject *pObject, DQMMonitorElementType type,
		const std::string &name, const std::string &title,
		const std::string &moduleName) :
		m_type(type),
		m_name(name),
		m_title(title),
		m_description(""),
		m_moduleName(moduleName),
		m_drawOption(""),
		m_quality(NO_QUALITY),
		m_resetPolicy(END_OF_RUN_RESET_POLICY),
		m_runNumber(0),
		m_toPublish(true),
		m_pObject(pObject)
{
	if(NULL == m_pObject)
		throw StatusCodeException(STATUS_CODE_INVALID_PARAMETER);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElement::~DQMMonitorElement()
{
	if(NULL != m_pObject)
		delete m_pObject;

	m_qualityTestMap.clear();
	m_qualityTestResultMap.clear();
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getModuleName() const
{
	return m_moduleName;
}

//-------------------------------------------------------------------------------------------------

DQMQuality DQMMonitorElement::getQuality() const
{
	return m_quality;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setQuality(DQMQuality quality)
{
	m_quality = quality;
}

//-------------------------------------------------------------------------------------------------

DQMResetPolicy DQMMonitorElement::getResetPolicy() const
{
	return m_resetPolicy;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setResetPolicy(DQMResetPolicy policy)
{
	m_resetPolicy = policy;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementType DQMMonitorElement::getType() const
{
	return m_type;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getName() const
{
	return m_name;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getTitle() const
{
	return m_title;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setTitle(const std::string &title)
{
	m_title = title;

	if(m_pObject)
	{
		TNamed *pNamed = dynamic_cast<TNamed*>(m_pObject);

		if(pNamed)
			pNamed->SetTitle(title.c_str());
	}
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getDescription() const
{
	return m_description;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setDescription(const std::string &description)
{
	m_description = description;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getDrawOption() const
{
	return m_drawOption;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setDrawOption(const std::string &drawOption)
{
	m_drawOption = drawOption;

	if(m_pObject)
		m_pObject->SetDrawOption(drawOption.c_str());
}

//-------------------------------------------------------------------------------------------------

unsigned int DQMMonitorElement::getRunNumber() const
{
	return m_runNumber;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setToPublish(bool toPublish)
{
	m_toPublish = toPublish;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElement::isToPublish() const
{
	return m_toPublish;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setRunNumber(unsigned int runNumber)
{
	m_runNumber = runNumber;
}

//-------------------------------------------------------------------------------------------------

TObject *DQMMonitorElement::getObject() const
{
	return m_pObject;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::reset()
{
	m_pObject->Clear();

	// special case for histograms
	TH1 *pHistogram = dynamic_cast<TH1 *>(m_pObject);

	if(NULL != pHistogram)
		pHistogram->Reset();
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElement::isHistogram() const
{
	if( ! m_pObject )
		return false;

	return ( dynamic_cast<const TH1 *>(m_pObject) != 0 );
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElement::isScalar() const
{
	if(m_type >= INT_ELEMENT_TYPE && m_type <= STRING_ELEMENT_TYPE)
		return true;

	return false;
}

//-------------------------------------------------------------------------------------------------

const DQMPath &DQMMonitorElement::getPath() const
{
	return m_path;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setPath(const DQMPath &path)
{
	m_path = path;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElement::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElement::setCollectorName(const std::string &collectorName)
{
	m_collectorName = collectorName;
}

//-------------------------------------------------------------------------------------------------

const DQMQualityTestResultMap &DQMMonitorElement::getQualityTestResults() const
{
	return m_qualityTestResultMap;
}

//-------------------------------------------------------------------------------------------------

xdrstream::Status DQMMonitorElement::stream(xdrstream::StreamingMode mode, xdrstream::IODevice *pDevice,
		xdrstream::xdr_version_t version)
{
	if( xdrstream::XDR_READ_STREAM == mode )
	{
		int32_t elementType = 0;
		XDR_STREAM( pDevice->read( & elementType ) )

		std::string elementName;
		XDR_STREAM( pDevice->read( & elementName ) )

		std::string elementTitle;
		XDR_STREAM( pDevice->read( & elementTitle ) )

		bool hasTObject;
		XDR_STREAM( pDevice->read( & hasTObject ) )

		TObject *pObject = NULL;

		if(hasTObject)
		{
			if(elementType == INT_ELEMENT_TYPE)
			{
				int32_t value;
				XDR_STREAM( pDevice->read( & value ) )
				pObject = new TScalarInt(value);
			}
			else if(elementType == REAL_ELEMENT_TYPE)
			{
				float value;
				XDR_STREAM( pDevice->read( & value ) )
				pObject = new TScalarReal(value);
			}
			else if(elementType == SHORT_ELEMENT_TYPE)
			{
				int16_t value;
				XDR_STREAM( pDevice->read( & value ) )
				pObject = new TScalarShort(value);
			}
			else if(elementType == STRING_ELEMENT_TYPE)
			{
				std::string value;
				XDR_STREAM( pDevice->read( & value ) )
				pObject = new TScalarString(value);
			}
			else
			{
				char *pBuffer = NULL;
				xdrstream::xdr_size_t bufferSize = 0;
				XDR_STREAM( pDevice->readDynamicArray( pBuffer, bufferSize) )

				// buffer is adopted by TBufferFile
				TBufferFile bufferFile(TBuffer::kRead, bufferSize, pBuffer);
				pObject = bufferFile.ReadObject(0);
			}

			if(NULL == pObject)
				return STATUS_CODE_FAILURE;
		}

		int32_t elementQuality = static_cast<int32_t>(NO_QUALITY);
		XDR_STREAM( pDevice->read( & elementQuality ) )

		std::string drawOption;
		XDR_STREAM( pDevice->read( & drawOption ) )

		std::string path;
		XDR_STREAM( pDevice->read( & path ) )

		std::string collectorName;
		XDR_STREAM( pDevice->read( & collectorName ) )

		std::string moduleName;
		XDR_STREAM( pDevice->read( & moduleName ) )

		std::string elementDescription;
		XDR_STREAM( pDevice->read( & elementDescription ) )

		int32_t resetPolicy = static_cast<int32_t>(NO_RESET_POLICY);
		XDR_STREAM( pDevice->read( & resetPolicy ) )

		int32_t runNumber = 0;
		XDR_STREAM( pDevice->read( & runNumber ) )

		bool isToPublish = true;
		XDR_STREAM( pDevice->read( & isToPublish ) )

		uint32_t nQTestResults = 0;
		XDR_STREAM( pDevice->read( & nQTestResults ) )

		for(unsigned int q=0 ; q<nQTestResults ; q++)
		{
			std::string qTestName;
			XDR_STREAM( pDevice->read( & qTestName ) )

			DQMQualityTestResult qTestResult;
			XDR_STREAM( qTestResult.stream( mode , pDevice , version ) )

			m_qualityTestResultMap[qTestName] = qTestResult;
		}

		if(0 != m_pObject)
		{
			delete m_pObject;
			m_pObject = 0;
		}

		m_pObject = pObject;

		if(m_pObject)
		{
			TNamed *pNamed = dynamic_cast<TNamed*>(m_pObject);

			if(pNamed)
				pNamed->SetName((DQMPath(path) + elementName).getPath().c_str());
		}

		m_name = elementName;
		m_type = static_cast<DQMMonitorElementType>(elementType);
		m_moduleName = moduleName;

		this->setTitle(elementTitle);
		this->setQuality(static_cast<DQMQuality>(elementQuality));
		this->setDrawOption(drawOption);
		this->setPath(DQMPath(path));
		this->setCollectorName(collectorName);
		this->setDescription(elementDescription);
		this->setResetPolicy(static_cast<DQMResetPolicy>(resetPolicy));
		this->setRunNumber(runNumber);
		this->setToPublish(isToPublish);

		return xdrstream::XDR_SUCCESS;
	}
	else
	{
		int32_t elementType = static_cast<int32_t>(this->getType());
		XDR_STREAM( pDevice->write( & elementType ) )

		std::string elementName = this->getName();
		XDR_STREAM( pDevice->write( & elementName ) )

		std::string elementTitle = getTitle();
		XDR_STREAM( pDevice->write( & elementTitle ) )

		TObject *pObject = this->getObject();

		bool hasTObject = (NULL != pObject);
		XDR_STREAM( pDevice->write( & hasTObject ) )

		if(hasTObject)
		{
			if(elementType == INT_ELEMENT_TYPE)
			{
				int32_t value = this->get<TScalarInt>()->Get();
				XDR_STREAM( pDevice->write( & value ) )
			}
			else if(elementType == REAL_ELEMENT_TYPE)
			{
				float value = this->get<TScalarReal>()->Get();
				XDR_STREAM( pDevice->write( & value ) )
			}
			else if(elementType == SHORT_ELEMENT_TYPE)
			{
				int16_t value = this->get<TScalarShort>()->Get();
				XDR_STREAM( pDevice->write( & value ) )
			}
			else if(elementType == STRING_ELEMENT_TYPE)
			{
				std::string value = this->get<TScalarString>()->Get();
				XDR_STREAM( pDevice->write( & value ) )
			}
			else
			{
				// serialize
				TBufferFile bufferFile(TBuffer::kWrite);
				bufferFile.WriteObject(pObject);

				// get the buffer and length
				const char *pRawBuffer = bufferFile.Buffer();
				xdrstream::xdr_size_t bufferSize = bufferFile.BufferSize();

				// and write it
				XDR_STREAM( pDevice->writeArray( pRawBuffer , bufferSize ) )
			}
		}

		int32_t elementQuality = static_cast<int32_t>(this->getQuality());
		XDR_STREAM( pDevice->write( & elementQuality ) )

		std::string drawOption = this->getDrawOption();
		XDR_STREAM( pDevice->write( & drawOption ) )

		std::string path = this->getPath().getPath();
		XDR_STREAM( pDevice->write( & path ) )

		std::string collectorName = this->getCollectorName();
		XDR_STREAM( pDevice->write( & collectorName ) )

		std::string moduleName = this->getModuleName();
		XDR_STREAM( pDevice->write( & moduleName ) )

		std::string elementDescription = this->getDescription();
		XDR_STREAM( pDevice->write( & elementDescription ) )

		int32_t resetPolicy = static_cast<int32_t>(this->getResetPolicy());
		XDR_STREAM( pDevice->write( & resetPolicy ) )

		int32_t runNumber = static_cast<int32_t>(this->getRunNumber());
		XDR_STREAM( pDevice->write( & runNumber ) )

		bool isToPublish = this->isToPublish();
		XDR_STREAM( pDevice->write( & isToPublish ) )

		uint32_t nQTestResults = m_qualityTestResultMap.size();
		XDR_STREAM( pDevice->write( & nQTestResults ) )

		for(std::map<std::string, DQMQualityTestResult>::iterator iter = m_qualityTestResultMap.begin(),
				endIter = m_qualityTestResultMap.end() ; endIter != iter ; ++iter)
		{
			// write qtest name
			XDR_STREAM( pDevice->write( & iter->first ) )

			// write qtest result
			XDR_STREAM( iter->second.stream( mode , pDevice , version ) )
		}
	}

	return xdrstream::XDR_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::runQualityTest(const std::string &qualityTestName)
{
	std::map<std::string, DQMQualityTest*>::iterator findIter = m_qualityTestMap.find(qualityTestName);

	if(findIter == m_qualityTestMap.end())
		return STATUS_CODE_NOT_FOUND;

	DQMQualityTest *pQualityTest = findIter->second;
	DQMQualityTestResult result;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->run(this, result));

	m_qualityTestResultMap[pQualityTest->getName()] = result;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::runQualityTests()
{
	for(std::map<std::string, DQMQualityTest*>::iterator iter = m_qualityTestMap.begin(), endIter = m_qualityTestMap.end() ;
			endIter != iter ; ++iter)
	{
		DQMQualityTest *pQualityTest = iter->second;
		DQMQualityTestResult result;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->run(this, result));

		m_qualityTestResultMap[pQualityTest->getName()] = result;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::addQualityTest(DQMQualityTest *pQualityTest)
{
	if(NULL == pQualityTest)
		return STATUS_CODE_INVALID_PTR;

	std::map<std::string, DQMQualityTest*>::iterator findIter = m_qualityTestMap.find(pQualityTest->getName());

	if(m_qualityTestMap.end() != findIter)
		return STATUS_CODE_ALREADY_PRESENT;

	if(!m_qualityTestMap.insert(std::map<std::string, DQMQualityTest*>::value_type(pQualityTest->getName(), pQualityTest)).second)
		return STATUS_CODE_FAILURE;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::removeQualityTest(DQMQualityTest *pQualityTest)
{
	if(NULL == pQualityTest)
		return STATUS_CODE_INVALID_PTR;

	return removeQualityTest(pQualityTest->getName());
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElement::removeQualityTest(const std::string &qualityTestName)
{
	std::map<std::string, DQMQualityTest*>::iterator findIter = m_qualityTestMap.find(qualityTestName);

	if(m_qualityTestMap.end() == findIter)
		return STATUS_CODE_NOT_FOUND;

	m_qualityTestMap.erase(findIter);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

TDynamicGraph::TDynamicGraph() :
		TGraph(),
		m_rangeLength(-1.)
{
	SetBit(kDynamicRange);
	SetBit(kShrinkToRange);
}

//-------------------------------------------------------------------------------------------------

TDynamicGraph::~TDynamicGraph()
{

}

//-------------------------------------------------------------------------------------------------

void TDynamicGraph::SetRangeLength(Double_t rangeLength)
{
	m_rangeLength = rangeLength;
}

//-------------------------------------------------------------------------------------------------

void TDynamicGraph::AddPoint(Double_t x, Double_t y)
{
	Int_t nPoints = this->GetN();
	this->SetPoint(nPoints, x, y);
	this->ShrinkToRange();
}

//-------------------------------------------------------------------------------------------------

void TDynamicGraph::Draw(Option_t *option)
{
	TGraph::Draw(option);

	if( TestBit(kDynamicRange) )
	{
		Int_t nPoints = this->GetN();

		if( m_rangeLength <= 0 || nPoints == 0)
			return;

		Double_t lastX, lastY;
		Int_t res = this->GetPoint( nPoints-1 , lastX, lastY );

		this->GetXaxis()->SetRangeUser( lastX - m_rangeLength , lastX );

		if(gPad)
			gPad->Update();
	}
}

//-------------------------------------------------------------------------------------------------

void TDynamicGraph::ShrinkToRange()
{
	if( ! TestBit(kDynamicRange) || ! TestBit(kShrinkToRange) )
		return;

	Int_t nPoints = this->GetN();

	if( m_rangeLength <= 0 || nPoints == 0)
		return;

	Double_t lastX, lastY;
	Int_t res = this->GetPoint( nPoints-1 , lastX, lastY );

	if( res < 0 )
		return;

	Double_t xLimit = lastX - m_rangeLength;

	while(1)
	{
		Double_t x, y;
		res = this->GetPoint(0, x, y);

		if( res < 0 )
			break;

		if( x < xLimit )
			this->RemovePoint(0);
		else
			break;
	}
}

} 

