  /// \file DQM4HEP.cc
/*
 *
 * DQM4HEP.cc source template automatically generated by a class generator
 * Creation date : dim. oct. 5 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/DQM4HEP.h"

namespace dqm4hep
{

StatusCodeException::StatusCodeException(const StatusCode statusCode) :
		m_statusCode(statusCode)
{
#if defined(__GNUC__) && defined(BACKTRACE)
        const size_t maxDepth = 100;
        void *stackAddresses[maxDepth];

        size_t stackDepth = backtrace(stackAddresses, maxDepth);
        char **stackStrings = backtrace_symbols(stackAddresses, stackDepth);

        m_backTrace = "\nBackTrace\n    ";

        for (size_t i = 1; i < stackDepth; ++i)
        {
                m_backTrace += stackStrings[i];
                m_backTrace += "\n    ";
        }

        free(stackStrings); // malloc()ed by backtrace_symbols
#endif
}

//-------------------------------------------------------------------------------------------------

StatusCodeException::~StatusCodeException() throw()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

StatusCode StatusCodeException::getStatusCode() const
{
	return m_statusCode;
}

//-------------------------------------------------------------------------------------------------

std::string StatusCodeException::toString() const
{
	return statusCodeToString(m_statusCode);
}

//-------------------------------------------------------------------------------------------------

const std::string &StatusCodeException::getBackTrace() const
{
	return m_backTrace;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

void DQM4HEP::screenSplash()
{
	time_t t;
	time(&t);
	char *pTimeStr = new char[256];
	ctime_r(&t, pTimeStr);

	std::cout << "#######################################################" << std::endl;
	std::cout << "#" << std::endl;
	std::cout << "#                    DQM4HEP" << std::endl;
	std::cout << "#   (Data Quality Monitoring For High Energy Physics)" << std::endl;
	std::cout << "#" << std::endl;
	std::cout << "#      Version    : " << DQM4HEP_VERSION_STR << std::endl;
	std::cout << "#      Started at : " << pTimeStr << std::endl;
	std::cout << "#      Author     : R. Ete" << std::endl;
	std::cout << "#      Mail       : <rete@ipnl.in2p3.fr> " << std::endl;
	std::cout << "#" << std::endl;
	std::cout << "#######################################################" << std::endl;

	delete [] pTimeStr;
}

//-------------------------------------------------------------------------------------------------

void DQM4HEP::tokenize(const std::string &inputString, StringVector &tokens, const std::string &delimiter)
{
	std::string::size_type lastPos = inputString.find_first_not_of(delimiter, 0);
	std::string::size_type pos     = inputString.find_first_of(delimiter, lastPos);

	while ((std::string::npos != pos) || (std::string::npos != lastPos))
	{
		tokens.push_back(inputString.substr(lastPos, pos - lastPos));
		lastPos = inputString.find_first_not_of(delimiter, pos);
		pos = inputString.find_first_of(delimiter, lastPos);
	}
}

//-------------------------------------------------------------------------------------------------

DQMQuality DQM4HEP::scaleToQuality(float scale)
{
	if(scale > 0.f && scale < 0.2f)
		return VERY_BAD_QUALITY;
	else if(scale < 0.4f)
		return BAD_QUALITY;
	else if(scale < 0.6f)
		return NORMAL_QUALITY;
	else if(scale < 0.8f)
		return GOOD_QUALITY;
	else if(scale < 1.f)
		return VERY_GOOD_QUALITY;
	else
		return NO_QUALITY;
}

//-------------------------------------------------------------------------------------------------

void printRawBuffer(char *pBuffer, int bufferSize)
{
	std::cout << "taille : " << bufferSize << " address : " << (void *)pBuffer << std::endl;

	for(int i=0 ; i<bufferSize ; i++)
	{
		printf("%2x", pBuffer[i]);

		if(i%30 == 0)
			std::cout << std::endl;
	}

	std::cout << std::endl;
}

}
