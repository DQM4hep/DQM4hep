  /// \file DQMStorage.cc
/*
 *
 * DQMStorage.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 19 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMPath.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMDirectory.h"

namespace dqm4hep
{

DQMStorage::DQMStorage(bool owner) :
		m_isOwner(owner)
{
	m_pRootDir = new DQMDirectory("");
	m_pCurrentDir = m_pRootDir;
}

//-------------------------------------------------------------------------------------------------

DQMStorage::~DQMStorage()
{
	delete m_pRootDir;
	m_pCurrentDir = NULL;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::mkdir(const std::string &dirName)
{
	if(dirName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	DQMPath path(dirName);

	if(!path.isValid())
		return STATUS_CODE_INVALID_PARAMETER;

//	bool startFromRoot = dirName[0] == '/';
//	DQMDirectory *pDirectory = startFromRoot ? m_pRootDir : m_pCurrentDir;

	DQMDirectory *pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;

//	StringVector directoryList;
//	DQM4HEP::tokenize(dirName, directoryList, "/");

	StringVector directoryList = path.getSplitPath();

	for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
			endIter != iter ; ++iter)
	{
		std::string dirName = *iter;

		// if sub dir doesn't exists, create it
		if(!pDirectory->containsDir(dirName))
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->mkdir(dirName));

		// navigate forward
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findDir(dirName, pDirectory));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMStorage::cd()
{
	m_pCurrentDir = m_pRootDir;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::cd(const std::string &dirName)
{
	// go back to sub dir
	if(dirName.empty())
	{
		cd();
		return STATUS_CODE_SUCCESS;
	}

	DQMPath path(dirName);

	if(!path.isValid())
		return STATUS_CODE_INVALID_PARAMETER;

//	bool startFromRoot = dirName[0] == '/';
//	DQMDirectory *pDirectory = startFromRoot ? m_pRootDir : m_pCurrentDir;

	DQMDirectory *pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;

//	StringVector directoryList;
//	DQM4HEP::tokenize(dirName, directoryList, "/");

	StringVector directoryList = path.getSplitPath();

	for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
			endIter != iter ; ++iter)
	{
		std::string dirName = *iter;

		// navigate forward
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findDir(dirName, pDirectory));
	}

	if(NULL == pDirectory)
		return STATUS_CODE_FAILURE;

	m_pCurrentDir = pDirectory;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMStorage::ls(bool recursive) const
{
	m_pCurrentDir->ls(recursive);
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::dirExists(const std::string &dirName) const
{
	DQMDirectory *pDirectory = NULL;
	return findDir(dirName, pDirectory) == STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMStorage::pwd() const
{
	return m_pCurrentDir->getName();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::goUp()
{
	if(m_pCurrentDir->isRootDir())
		return STATUS_CODE_NOT_ALLOWED;

	m_pCurrentDir = m_pCurrentDir->getParentDir();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::rmdir(const std::string &dirName)
{
	if(dirName.empty())
		return STATUS_CODE_NOT_ALLOWED;

	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	if(pDirectory == m_pRootDir)
		return STATUS_CODE_NOT_ALLOWED;

	std::string fullPathDirName = pDirectory->getFullPathName();
	std::string currentFullPathDirName = m_pCurrentDir->getFullPathName();
	size_t pos = currentFullPathDirName.find(fullPathDirName);

	// this mean that the directory that we try
	// to remove is a parent of the current one.
	if(pos == 0 || pos != std::string::npos)
		return STATUS_CODE_FAILURE;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->getParentDir()->removeDir(pDirectory->getName(), m_isOwner));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::findDir(const std::string &dirName, DQMDirectory *&pDirectory) const
{
	pDirectory = NULL;

	// go back to sub dir
	if(dirName.empty() || dirName == "." || dirName == "./")
	{
		pDirectory = m_pCurrentDir;
		return STATUS_CODE_SUCCESS;
	}

	DQMPath path(dirName);

	if(!path.isValid())
		return STATUS_CODE_INVALID_PARAMETER;

//	bool startFromRoot = dirName[0] == '/';
//	DQMDirectory *pDirectory = startFromRoot ? m_pRootDir : m_pCurrentDir;

	pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;

//	StringVector directoryList;
//	DQM4HEP::tokenize(dirName, directoryList, "/");

	StringVector directoryList = path.getSplitPath();

	for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
			endIter != iter ; ++iter)
	{
		std::string dirName = *iter;

		// navigate forward
		StatusCode statusCode = pDirectory->findDir(dirName, pDirectory);

		if(statusCode != STATUS_CODE_SUCCESS)
			return statusCode;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMDirectory *DQMStorage::getRootDirectory() const
{
	return m_pRootDir;
}

//-------------------------------------------------------------------------------------------------

DQMDirectory *DQMStorage::getCurrentDirectory() const
{
	return m_pCurrentDir;
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::isOwner() const
{
	return m_isOwner;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::addMonitorElement(DQMMonitorElement *pMonitorElement)
{
	std::string fullPath = m_pCurrentDir->getFullPathName();

	pMonitorElement->setFullPath(fullPath); 	// deprecated
	pMonitorElement->setPath(DQMPath(fullPath));

	return m_pCurrentDir->addMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::addMonitorElement(const std::string &dirName, DQMMonitorElement *pMonitorElement)
{
	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, mkdir(dirName));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	std::string fullPath = pDirectory->getFullPathName();

	pMonitorElement->setFullPath(fullPath); 	// deprecated
	pMonitorElement->setPath(DQMPath(fullPath));

	return pDirectory->addMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::removeMonitorElement(const std::string &monitorElementName)
{
	DQMMonitorElement *pMonitorElement = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentDir->findMonitorElement(monitorElementName, pMonitorElement));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentDir->removeMonitorElement(pMonitorElement));

	pMonitorElement->setFullPath(""); 	// deprecated
	pMonitorElement->setPath(DQMPath(""));

	if(isOwner())
		delete pMonitorElement;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::removeMonitorElement(const std::string &dirName, const std::string &monitorElementName)
{
	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	DQMMonitorElement *pMonitorElement = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findMonitorElement(monitorElementName, pMonitorElement));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->removeMonitorElement(pMonitorElement));

	pMonitorElement->setFullPath(""); 	// deprecated
	pMonitorElement->setPath(DQMPath(""));

	if(isOwner())
		delete pMonitorElement;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::getMonitorElement(const std::string &monitorElementName, DQMMonitorElement *&pMonitorElement) const
{
	pMonitorElement = NULL;
	return m_pCurrentDir->findMonitorElement(monitorElementName, pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::getMonitorElement(const std::string &dirName, const std::string &monitorElementName, DQMMonitorElement *&pMonitorElement) const
{
	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	return pDirectory->findMonitorElement(monitorElementName, pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::monitorElementExists(DQMMonitorElement *pMonitorElement) const
{
	return m_pCurrentDir->containsMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::monitorElementExists(const std::string &dirName, DQMMonitorElement *pMonitorElement) const
{
	DQMDirectory *pDirectory = NULL;

	if(!dirExists(dirName))
		return false;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	return pDirectory->containsMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::getAllMonitorElements(std::vector<DQMMonitorElement*> &monitorElementList)
{
	return DQMStorage::recursiveContentList(m_pRootDir, monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::recursiveContentList(DQMDirectory *pDirectory, std::vector<DQMMonitorElement*> &monitorElementList)
{
	if(NULL == pDirectory)
		return STATUS_CODE_INVALID_PTR;

	// add directory contents
	const std::vector<DQMMonitorElement*> &directoryMonitorElementList(pDirectory->getMonitorElementList());
	monitorElementList.insert(monitorElementList.end(), directoryMonitorElementList.begin(), directoryMonitorElementList.end());

	// get the sub dir list ...
	const std::vector<DQMDirectory*> &subDirList(pDirectory->getSubDirList());

	if(subDirList.empty())
		return STATUS_CODE_SUCCESS;

	// ... and loop over to add the contents
	for(std::vector<DQMDirectory*>::const_iterator iter = subDirList.begin(), endIter = subDirList.end() ;
			endIter != iter ; ++iter)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMStorage::recursiveContentList(*iter, monitorElementList));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::clear()
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRootDir->clear(true));
	m_pCurrentDir = m_pRootDir;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

} 

