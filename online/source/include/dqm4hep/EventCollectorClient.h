/*
 *
 * EventCollectorClient.h header template automatically generated by a class generator
 * Creation date : mer. sept. 9 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQM4HEP_EVENTCOLLECTORCLIENT_H
#define DQM4HEP_EVENTCOLLECTORCLIENT_H

// -- dqm4hep headers
#include "dqm4hep/Internal.h"
#include "dqm4hep/StatusCodes.h"
#include "dqm4hep/EventStreamer.h"
#include "dqm4hep/Client.h"

// -- xdrstream headers
#include <xdrstream/BufferDevice.h>

// -- std headers
#include <mutex>

namespace dqm4hep {

  namespace online {
    
    /** 
     *  @brief  EventCollectorClient class
     */
    class EventCollectorClient {
    public:
      ~EventCollectorClient() = default;
      
      /**
       *  @brief  Default constructor
       *
       *  @param  collectorName the collector name to connect to 
       */
      EventCollectorClient(const std::string &collectorName);
      
      /**
       *  @brief  Request the last collected event in the collector
       */
      core::EventPtr queryEvent(const std::string &source);
      
      /**
       *  @brief  Get the signal for event updates for a given source
       *          If the source is not yet registered internally here,
       *          it is created and returned in any case
       *
       *  @param  source the source name
       *  @param  controller the object receiving the event
       *  @param  function the object function receiving the event
       */
      template <typename Controller>
      void onEventUpdate(const std::string &source, Controller *controller, void (Controller::*function)(core::EventPtr event));
      
      /**
       *  @brief  Instruct the event collector to send the latest received 
       *          event when a new one is available for a given source
       *
       *  @param  source the source name
       */
      void startEventUpdates(const std::string &source);
      
      /**
       *  @brief  Instruct the event collector to stop sending event
       */
      void stopEventUpdates(const std::string &source);
      
      /**
       *  @brief  Whether the client is currently receiving event updates from the collector
       */
      bool receivingEventUpdates(const std::string &source) const;
      
      void startEventUpdates();
      void stopEventUpdates();
      
    private:
      void setUpdateMode(const std::string &source, bool receiveUpdates);
      core::EventPtr readEvent(const net::Buffer &buffer);

    private:
      
      using BufferDevicePtr = std::shared_ptr<xdrstream::BufferDevice>;
      using EventUpdateSignal = core::Signal<core::EventPtr>;
      
      /**
       *  @brief  SourceInfo struct
       */
      struct SourceInfo {
        EventUpdateSignal       m_eventUpdateSignal = {};      ///< The signal to process on event update
        EventCollectorClient   *m_collectorClient = {nullptr};
        void receiveEvent(const net::Buffer &buffer);
      };
      friend struct SourceInfo;
      using SourceInfoMap = std::map<std::string, SourceInfo>;
      
    private:
      std::string                         m_collectorName = {""};
      SourceInfoMap                       m_sourceInfoMap = {};
      net::Client                         m_client = {};
      mutable std::recursive_mutex        m_mutex = {};
      core::EventStreamer                 m_eventStreamer = {};
      BufferDevicePtr                     m_bufferDevice = {nullptr};
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    template <typename Controller>
    inline void EventCollectorClient::onEventUpdate(const std::string &source, Controller *controller, void (Controller::*function)(core::EventPtr event)) {
      std::lock_guard<std::recursive_mutex> lock(m_mutex);
      auto &info = m_sourceInfoMap[source];
      info.m_collectorClient = this;
      info.m_eventUpdateSignal.connect(controller, function);
    }

  }

} 

#endif  //  DQM4HEP_EVENTCOLLECTORCLIENT_H
